# eblog

​	eblog 是一个根据B站UP主[MarkerHub](https://space.bilibili.com/13491144)、基于 Springboot 开发的博客学习项目，视频链接https://www.bilibili.com/video/BV1ri4y1x71A。主要功能有：自定义 Freemarker 标签，使用 shiro+redis 完成会话共享，redis 的 zset 结构完成本周热议排行榜，t-io+websocket 完成即时消息通知和群聊，rabbitmq+elasticsearch 完成博客内容搜索引擎等。虽然内容很多，但是我还是把重点放在了后端实现的逻辑上，并未过多关注前端的实现。

> 项目文档：https://juejin.cn/post/5ee88c58518825434c3db0e5
>
> 讲解视频：https://www.bilibili.com/video/BV1ri4y1x71A
>
> 部署视频：https://www.bilibili.com/video/BV1dk4y1r7pi
>
> 项目源码：https://github.com/MarkerHub/eblog
>
> 前端页面素材：链接: https://pan.baidu.com/s/1u9iZ-KJ3U5B6O_sD_5iuKw 提取码: pcfb

## 1.项目搭建



![image-20220207195608931](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220207195608931.png)

pom.xml 的依赖包如下：

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.lyj</groupId>
    <artifactId>eblog</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>eblog</name>
    <description>eblog</description>
    <properties>
        <java.version>11</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-freemarker</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!--mybatisPlus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.1</version>
        </dependency>
        <!-- sql分析器 -->
        <dependency>
            <groupId>p6spy</groupId>
            <artifactId>p6spy</artifactId>
            <version>3.8.6</version>
        </dependency>

        <!-- commons-lang3 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.9</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

在 `application.yml` 中编写配置文件：

```yaml
# DataSource Config
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
#    driver-class-name: com.p6spy.engine.spy.P6SpyDriver
#    url: jdbc:p6spy:mysql://localhost:3306/eblog?useSSL=true&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    url: jdbc:mysql://localhost:3306/eblog?useSSL=true&useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    username: root
    password: 7012+2
    hikari:
      # 连接池名
      pool-name: DateHikariCP
      # 最小空闲连接池
      minimum-idle: 5
      # 最大连接数 默认10
      maximum-pool-size: 10
      # 连接池返回的连接自动提交
      auto-commit: true
      # 连接最大存活时间 0表示永久存活 默认1800000 （30分钟）
      max-lifetime: 1800000
      # 连接超时时间 默认30000（30秒）
      connection-timeout: 30000
      # 测试连接是否可用的查询语句
      connection-test-query: select 1
```

新建数据库，并使用 MybatisPlus 代码生成器自动生成对应的类。

## 2.页面

![Snipaste_2022-02-11_09-45-46](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/Snipaste_2022-02-11_09-45-46.png)

根据上图将首页划分为几个区域，前端页面的实现忽略，只关注后端代码。

- 有些数据是项目启动的时候就需要的

  - ```java
    /**
     * 实现功能：
     * 项目启动的时候便运行以下代码: header-panel中的类别
     *
     */
    @Component
    public class ContextStartUp implements ApplicationRunner, ServletContextAware {
    
        @Autowired
        ICategoryService categoryService;
    
        ServletContext servletContext;
    
        @Autowired
        IPostService postService;
    
        @Override
        public void run(ApplicationArguments args) throws Exception {
    
            List<Category> categories = categoryService.list(new QueryWrapper<Category>()
                    .eq("status", 0)
            );
            servletContext.setAttribute("categories", categories);
    
            /*本周热议
            *
            * 项目启功的时候便初始化
            * */
            postService.initWeekRank();
        }
    
        @Override
        public void setServletContext(ServletContext servletContext) {
            this.servletContext = servletContext;
        }
    }
    
    ```

- **首页**

  - ```java
    @Controller
    public class IndexController extends BaseController {
    
        @RequestMapping({"", "/", "/index"})
        public String index() {
    
            /*参数：1分页信息 2分类 3用户 4置顶 5精选 6排序*/
            IPage results = postService.paging(getPage(), null, null, null, null, "created");
            /*分页的数据*/
            request.setAttribute("pageData", results);
    
            /*默认首页的id是0*/
            request.setAttribute("currentCategoryId", 0);
            return "index";
        }
    }
    ```

  - ```java
    /**
     *  服务类
     *
     * @author LiuYunJie
     * @since 2022-02-08
     */
    public interface IPostService extends IService<Post> {
        /**
         * 自实现的分页功能
         * @param page          分页信息
         * @param categoryId    分类信息
         * @param userId        用户信息
         * @param level         置顶等级
         * @param recommend     是否推荐
         * @param order         排序方式
         * @return
         */
        IPage paging(Page page, Long categoryId, Long userId, Integer level,
                     Boolean recommend, String order);
    }
    
    ```

  - ```java
    /**
     *  服务实现类
     *
     * @author LiuYunJie
     * @since 2022-02-08
     */
    @Service
    public class PostServiceImpl extends ServiceImpl<PostMapper, Post> implements IPostService {
    
        @Autowired
        PostMapper postMapper;
    
        @Autowired
        RedisUtil redisUtil;
    
        @Override
        public IPage paging(Page page, Long categoryId, Long userId,
                            Integer level, Boolean recommend, String order) {
            if (level == null) {
                level = -1;
            }
            QueryWrapper<Post> wrapper = new QueryWrapper<Post>()
    
                    .eq(categoryId != null, "category_id", categoryId)
                    .eq(userId != null, "user_id", userId)
                    .eq(level == 0, "level", 0)
                    .gt(level > 0, "level", 0)
                    .orderByDesc(order != null, order);
            return postMapper.selectPosts(page, wrapper);
        }
    
        /**
         * 本周热议
         */
        @Override
        public void initWeekRank() {
    
            /*获取7天内发表的文章*/
            List<Post> posts = this.list(new QueryWrapper<Post>()
                    .ge("created", DateUtil.lastWeek())
                    .select("id, title, user_id, comment_count, view_count, created"));
    
            /*初始化文章的总评论量*/
            for (Post post: posts) {
                String key = "day:rank:" + DateUtil.format(post.getCreated(),
                        DatePattern.PURE_DATE_FORMAT);
                redisUtil.zSet(key, post.getId(), post.getCommentCount());
    
                /*7天后自动过期*/
                long between = DateUtil.between(new Date(), post.getCreated(), DateUnit.DAY); // 天
                long expireTime = (7 - between) * 24 * 3600; // 剩余过期时间 秒
    
                redisUtil.expire(key, expireTime); /*设置key的存活时间*/
    
                /*缓存文章的一些基本信息(id、标题、评论数量、作者)*/
                this.hashCachePostInformation(post, expireTime);
    
            }
    
            /*并集*/
            this.zunionAndStoredLast7DayForWeekRank();
    
        }
    
        /**
         * 评论数增加以后自动更新本周热议功能
         * @param postId
         * @param isIncr
         */
        @Override
        public void incrCommentCountAndUnionForWeekRank(long postId, boolean isIncr) {
            String  currentKey = "day:rank:" + DateUtil.format(new Date(), DatePattern.PURE_DATE_FORMAT);
            redisUtil.zIncrementScore(currentKey, postId, isIncr? 1: -1);
    
            Post post = this.getById(postId);
    
            // 7天后自动过期(15号发表，7-（18-15）=4)
            long between = DateUtil.between(new Date(), post.getCreated(), DateUnit.DAY);
            long expireTime = (7 - between) * 24 * 60 * 60; // 有效时间
    
            // 缓存这篇文章的基本信息
            this.hashCachePostInformation(post, expireTime);
    
            // 重新做并集
            this.zunionAndStoredLast7DayForWeekRank();
        }
    
        /**
         * 阅读量加1
         * @param postVo
         */
        @Override
        public void putViewCount(PostVo postVo) {
            String key = "rank:post:" + postVo.getId();
    
            /*1 从缓存中获取viewCount(阅读量)*/
            Integer viewCount = (Integer) redisUtil.hget(key, "post:viewCount");
    
            /*2 如果没有 就从数据库中获取 再加1*/
            if (viewCount !=null) {
                postVo.setViewCount(viewCount + 1);
            } else {
                postVo.setViewCount(postVo.getViewCount() + 1);
            }
    
            /*3 同步到缓存中*/
            redisUtil.hset(key, "post:viewCount", postVo.getViewCount());
        }
    
        /**
         * 本周合并每日评论数量操作
         */
        private void zunionAndStoredLast7DayForWeekRank() {
            String  currentKey = "day:rank:" + DateUtil.format(new Date(), DatePattern.PURE_DATE_FORMAT);
    
            String destKey = "week:rank";
            List<String> otherKeys = new ArrayList<>();
            for(int i=-6; i < 0; i++) {
                String temp = "day:rank:" +
                        DateUtil.format(DateUtil.offsetDay(new Date(), i), DatePattern.PURE_DATE_FORMAT);
    
                otherKeys.add(temp);
            }
    
            redisUtil.zUnionAndStore(currentKey, otherKeys, destKey);
        }
    
        /**
         * 缓存文章的基本信息
         * @param post
         * @param expireTime
         */
        private void hashCachePostInformation(Post post, long expireTime) {
            String key = "rank:post:" + post.getId();
            boolean hasKey = redisUtil.hasKey(key);
            if (!hasKey) {
                redisUtil.hset(key, "post:id", post.getId(), expireTime);
                redisUtil.hset(key, "post:title", post.getTitle(), expireTime);
                redisUtil.hset(key, "post:commentCount", post.getCommentCount(), expireTime);
                redisUtil.hset(key, "post:viewCount", post.getViewCount(), expireTime);
            }
        }
    }
    ```

  - ```java
    @Component
    public interface PostMapper extends BaseMapper<Post> {
    
        IPage<PostVo> selectPosts(Page page,
                                  @Param(Constants.WRAPPER) QueryWrapper<Post> wrapper);
    
        PostVo selectOnePost(@Param(Constants.WRAPPER)QueryWrapper<Post> wrapper);
    }
    ```

  - ```java
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.lyj.eblog.mapper.PostMapper">
    
        <!-- 通用查询映射结果 -->
        <resultMap id="BaseResultMap" type="com.lyj.eblog.pojo.Post">
            <id column="id" property="id" />
            <result column="title" property="title" />
            <result column="content" property="content" />
            <result column="edit_mode" property="editMode" />
            <result column="category_id" property="categoryId" />
            <result column="user_id" property="userId" />
            <result column="vote_up" property="voteUp" />
            <result column="vote_down" property="voteDown" />
            <result column="view_count" property="viewCount" />
            <result column="comment_count" property="commentCount" />
            <result column="recommend" property="recommend" />
            <result column="level" property="level" />
            <result column="status" property="status" />
            <result column="created" property="created" />
            <result column="modified" property="modified" />
        </resultMap>
    
        <!-- 通用查询结果列 -->
        <sql id="Base_Column_List">
            id, title, content, edit_mode, category_id, user_id, vote_up, vote_down, view_count, comment_count, recommend, level, status, created, modified
        </sql>
    
        <select id="selectPosts" resultType="com.lyj.eblog.Vo.PostVo">
            SELECT
                p.*,
                u.id AS authorId,
                u.username AS authorName,
                u.avatar AS authorAvatar,
    
                c.id AS categoryId,
                c.name AS categoryName
            FROM
                m_post p
                    LEFT JOIN m_user u ON p.user_id = u.id
                    LEFT JOIN m_category c ON p.category_id = c.id
            ${ew.customSqlSegment}
        </select>
    
        <select id="selectOnePost" resultType="com.lyj.eblog.Vo.PostVo">
            SELECT
                p.*,
                u.id AS authorId,
                u.username AS authorName,
                u.avatar AS authorAvatar,
    
                c.id AS categoryId,
                c.name AS categoryName
            FROM
                m_post p
                    LEFT JOIN m_user u ON p.user_id = u.id
                    LEFT JOIN m_category c ON p.category_id = c.id
                ${ew.customSqlSegment}
        </select>
    </mapper>
    
    ```

> BaseController 的作用是减少重复的代码，将一些相似的代码放到一起。

```java
@Controller
public class BaseController {

    @Autowired
    HttpServletRequest request;

    @Autowired
    IPostService postService;

    @Autowired
    ICommentService commentService;

    @Autowired
    IUserService userService;

    @Autowired
    IUserMessageService userMessageService;

    @Autowired
    IUserCollectionService userCollectionService;

    @Autowired
    ICategoryService categoryService;

    @Autowired
    WsService wsService;

    @Autowired
    SearchService searchService;

    @Autowired
    AmqpTemplate amqpTemplate;

    public Page getPage() {
        int pn = ServletRequestUtils.getIntParameter(request, "pn", 1);
        int size = ServletRequestUtils.getIntParameter(request, "size", 2);
        return new Page(pn, size);
    }

    protected AccountProfile getProfile() {
        return (AccountProfile)SecurityUtils.getSubject().getPrincipal();
    }

    protected Long getProfileId() {
        return getProfile().getId();
    }
}
```







### 2.1导航栏

```java
/**
 * 实现功能：
 * 项目启动的时候便运行以下代码: header-panel中的类别
 *
 */
@Component
public class ContextStartUp implements ApplicationRunner, ServletContextAware {

    @Autowired
    ICategoryService categoryService;

    ServletContext servletContext;

    @Override
    public void run(ApplicationArguments args) throws Exception {

        List<Category> categories = categoryService.list(new QueryWrapper<Category>()
                .eq("status", 0)
        );
        servletContext.setAttribute("categories", categories);
    }

    @Override
    public void setServletContext(ServletContext servletContext) {
        this.servletContext = servletContext;
    }
}
```



![image-20220210105417833](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220210105417833.png)

### 2.2 分页

分页并不是使用的 MybatisPlus 自带的分页功能，而是根据不同场景的需求，自己在 MybatisPlus 的基础上是实现的。

#### 2.2.1 首页的分页

![image-20220221215041390](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220221215041390.png)

根据观察可知，需要的不仅仅是博客的信息、还有作者的信息。

`IndexController`

```java
@Controller
public class IndexController extends BaseController {

    @RequestMapping({"", "/", "/index"})
    public String index() {

        /*参数：1分页信息 2分类 3用户 4置顶 5精选 6排序*/
        IPage results = postService.paging(getPage(), null, null, null, null, "created");
        /*分页的数据*/
        request.setAttribute("pageData", results);

        /*默认首页的id是0*/
        request.setAttribute("currentCategoryId", 0);
        return "index";
    }
}
```

`IPostService`

```java
public interface IPostService extends IService<Post> {

    /**
     * 自实现的分页功能
     * @param page          分页信息
     * @param categoryId    分类信息
     * @param userId        用户信息
     * @param level         置顶等级
     * @param recommend     是否推荐
     * @param order         排序方式
     * @return
     */
    IPage paging(Page page, Long categoryId, Long userId, Integer level,
                 Boolean recommend, String order);
```



```java
@Service
public class PostServiceImpl extends ServiceImpl<PostMapper, Post> implements IPostService {

    @Autowired
    PostMapper postMapper;

    @Override
    public IPage paging(Page page, Long categoryId, Long userId,
                        Integer level, Boolean recommend, String order) {
        if (level == null) {
            level = -1;
        }
        QueryWrapper<Post> wrapper = new QueryWrapper<Post>()
                .eq(categoryId != null, "category_id", categoryId)
                .eq(userId != null, "user_id", userId)
                .eq(level == 0, "level", 0)
                .gt(level > 0, "level", 0)
                .orderByDesc(order != null, order);
        return postMapper.selectPosts(page, wrapper);
    }
}
```

`PostMapper.java`

```java
@Component
public interface PostMapper extends BaseMapper<Post> {

    IPage<PostVo> selectPosts(Page page,
                              @Param(Constants.WRAPPER) QueryWrapper<Post> wrapper);
```

`PostMapper.xml`

```xml
<select id="selectPosts" resultType="com.lyj.eblog.Vo.PostVo">
    SELECT
    p.*,

    u.id AS authorId,
    u.username AS authorName,
    u.avatar AS authorAvatar,

    c.id AS categoryId,
    c.name AS categoryName
    FROM
    m_post p
    LEFT JOIN m_user u ON p.user_id = u.id
    LEFT JOIN m_category c ON p.category_id = c.id
    ${ew.customSqlSegment}
</select>
```

#### 2.2.2 我的主页的分页

![image-20220221223505269](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220221223505269.png)

`UserController`

```java
    /*我的消息*/
    @GetMapping("/user/mess")
    public String mess() {

        IPage<UserMessageVo> page = userMessageService.paging(getPage(), new QueryWrapper<UserMessage>()
                .eq("to_user_id", getProfileId())
                .orderByDesc("created")
        );
```

`IUserMessageService`

```java
/**
 * <p>
 *  服务类
 * </p>
 *
 * @author LiuYunJie
 * @since 2022-02-08
 */
public interface IUserMessageService extends IService<UserMessage> {

    IPage paging(Page page, QueryWrapper<UserMessage> wrapper);

}
```

`UserMessageServiceImpl`

```java
@Service
public class UserMessageServiceImpl extends ServiceImpl<UserMessageMapper, UserMessage> implements IUserMessageService {

    @Autowired
    UserMessageMapper userMessageMapper;

    @Override
    public IPage paging(Page page, QueryWrapper<UserMessage> wrapper) {
        return userMessageMapper.selectMessage(page, wrapper);
    }
}
```

`UserMessageMapper`

```java
@Component
public interface UserMessageMapper extends BaseMapper<UserMessage> {

    IPage<UserMessageVo> selectMessage(Page page,
                       @Param(Constants.WRAPPER) QueryWrapper<UserMessage> wrapper);
}
```

`UserMessageMapper.xml`

```xml
    <select id="selectMessage" resultType="com.lyj.eblog.Vo.UserMessageVo">
        SELECT
            m.*, (
            SELECT
                username
            FROM
                `m_user`
            WHERE
                id = m.from_user_id
        ) AS fromUserName,
            (
                SELECT
                    title
                FROM
                    `m_post`
                WHERE
                    id = m.post_id
            ) AS postTitle
        FROM
            `m_user_message` m

            ${ew.customSqlSegment}
    </select>
```

#### 2.2.3 MybatisPlus自带

`UserController`

```java
    /*发表的文章*/
    @ResponseBody
    @GetMapping("/user/public")
    public Result userPublic() {
        IPage page = postService.page(getPage(), new QueryWrapper<Post>()
                .eq("user_id", getProfileId())
                .orderByDesc("created"));
        return Result.success(page);
    }

    /*收藏的文章*/
    @ResponseBody
    @GetMapping("/user/collection")
    public Result collection() {
        IPage page = postService.page(getPage(), new QueryWrapper<Post>()
                .inSql("id", "SELECT post_id FROM m_user_collection where user_id = " + getProfileId())
        );
        return Result.success(page);
    }
```

因为这两种需求只需要文章的信息(即只需要一个数据库表)即可。

## 3. 本周热议、文章阅读量

### 3.1 本周热议

> 本周：7天内
>
> 热议：评论最多
>
> 思路：单独记录每天的评论量。
>
> 方法：使用 Redis 的 Zset，存储日期以及文章id。

- 因为本周热议是项目启动就存在，所以在 ContextStartUp.java 中编写该功能。

  - ```java
            /*本周热议
            *
            * 项目启功的时候便初始化
            * */
            postService.initWeekRank();
    ```

- 实现该方法

  - ```java
    /**
     *  服务实现类
     *
     * @author LiuYunJie
     * @since 2022-02-08
     */
    @Service
    public class PostServiceImpl extends ServiceImpl<PostMapper, Post> implements IPostService {
    
        @Autowired
        PostMapper postMapper;
    
        @Autowired
        RedisUtil redisUtil;
    
        @Override
        public IPage paging(Page page, Long categoryId, Long userId,
                            Integer level, Boolean recommend, String order) {
            if (level == null) {
                level = -1;
            }
            QueryWrapper<Post> wrapper = new QueryWrapper<Post>()
    
                    .eq(categoryId != null, "category_id", categoryId)
                    .eq(userId != null, "user_id", userId)
                    .eq(level == 0, "level", 0)
                    .gt(level > 0, "level", 0)
                    .orderByDesc(order != null, order);
            return postMapper.selectPosts(page, wrapper);
        }
    
        @Override
        public PostVo selectOnePost(QueryWrapper<Post> wrapper) {
            return postMapper.selectOnePost(wrapper);
        }
    
        /**
         * 本周热议
         */
        @Override
        public void initWeekRank() {
    
            /*获取7天内发表的文章*/
            List<Post> posts = this.list(new QueryWrapper<Post>()
                    .ge("created", DateUtil.lastWeek())
                    .select("id, title, user_id, comment_count, view_count, created"));
    
            /*初始化文章的总评论量*/
            for (Post post: posts) {
                String key = "day:rank:" + DateUtil.format(post.getCreated(),
                        DatePattern.PURE_DATE_FORMAT);
                redisUtil.zSet(key, post.getId(), post.getCommentCount());
    
                /*7天后自动过期*/
                long between = DateUtil.between(new Date(), post.getCreated(), DateUnit.DAY); // 天
                long expireTime = (7 - between) * 24 * 3600; // 剩余过期时间 秒
    
                redisUtil.expire(key, expireTime); /*设置key的存活时间*/
    
                /*缓存文章的一些基本信息(id、标题、评论数量、作者)*/
                this.hashCachePostInformation(post, expireTime);
    
            }
    
            /*并集*/
            this.zunionAndStoredLast7DayForWeekRank();
    
        }
        /**
         * 本周合并每日评论数量操作
         */
        private void zunionAndStoredLast7DayForWeekRank() {
            String  currentKey = "day:rank:" + DateUtil.format(new Date(), DatePattern.PURE_DATE_FORMAT);
    
            String destKey = "week:rank";
            List<String> otherKeys = new ArrayList<>();
            for(int i=-6; i < 0; i++) {
                String temp = "day:rank:" +
                        DateUtil.format(DateUtil.offsetDay(new Date(), i), DatePattern.PURE_DATE_FORMAT);
    
                otherKeys.add(temp);
            }
    
            redisUtil.zUnionAndStore(currentKey, otherKeys, destKey);
        }
    
        /**
         * 缓存文章的基本信息
         * @param post
         * @param expireTime
         */
        private void hashCachePostInformation(Post post, long expireTime) {
            String key = "rank:post:" + post.getId();
            boolean hasKey = redisUtil.hasKey(key);
            if (!hasKey) {
                redisUtil.hset(key, "post:id", post.getId(), expireTime);
                redisUtil.hset(key, "post:title", post.getTitle(), expireTime);
                redisUtil.hset(key, "post:commentCount", post.getCommentCount(), expireTime);
                redisUtil.hset(key, "post:viewCount", post.getViewCount(), expireTime);
            }
        }
            /**
         * 评论数增加以后自动更新本周热议功能
         * @param postId
         * @param isIncr
         */
        @Override
        public void incrCommentCountAndUnionForWeekRank(long postId, boolean isIncr) {
            String  currentKey = "day:rank:" + DateUtil.format(new Date(), DatePattern.PURE_DATE_FORMAT);
            redisUtil.zIncrementScore(currentKey, postId, isIncr? 1: -1);
    
            Post post = this.getById(postId);
    
            // 7天后自动过期(15号发表，7-（18-15）=4)
            long between = DateUtil.between(new Date(), post.getCreated(), DateUnit.DAY);
            long expireTime = (7 - between) * 24 * 60 * 60; // 有效时间
    
            // 缓存这篇文章的基本信息
            this.hashCachePostInformation(post, expireTime);
    
            // 重新做并集
            this.zunionAndStoredLast7DayForWeekRank();
        }
    }
    ```
  
- 定义模板，**没看懂**

  - ```java
    /**
     * 本周热议
     */
    @Component
    public class HotsTemplate extends TemplateDirective {
    
        @Autowired
        RedisUtil redisUtil;
    
        @Override
        public String getName() {
            return "hots";
        }
    
        @Override
        public void execute(DirectiveHandler handler) throws Exception {
            String weekRankKey = "week:rank";
    
            Set<ZSetOperations.TypedTuple> typedTuples = redisUtil.getZSetRank(weekRankKey, 0, 6);
    
            List<Map> hotPosts = new ArrayList<>();
    
            for (ZSetOperations.TypedTuple typedTuple : typedTuples) {
                Map<String, Object> map = new HashMap<>();
    
                Object value = typedTuple.getValue(); // post的id
                String postKey = "rank:post:" + value;
    
                map.put("id", value);
                map.put("title", redisUtil.hget(postKey, "post:title"));
                map.put("commentCount", typedTuple.getScore());
    
                hotPosts.add(map);
            }
    
            handler.put(RESULTS, hotPosts).render();
        }
    }
    
    ```
  
- 修改前端页面

### 3.2 文章阅读量

- 阅读量+1功能：

  - PostController.java

  - ```java
            /**
             * 阅读量加1
             * */
            postService.putViewCount(postVo);
    ```

  - PostServerImpl.java

  - ```java
        @Override
        public void putViewCount(PostVo vo) {
            String key = "rank:post:" + vo.getId();
    
            // 1、从缓存中获取viewcount
            Integer viewCount = (Integer) redisUtil.hget(key, "post:viewCount");
    
            // 2、如果没有，就先从实体里面获取，再加一
            if(viewCount != null) {
                vo.setViewCount(viewCount + 1);
            } else {
                vo.setViewCount(vo.getViewCount() + 1);
            }
    
            // 3、同步到缓存里面
            redisUtil.hset(key, "post:viewCount", vo.getViewCount());
        }
    ```

- **定时器**：缓存与数据库同步

  - ```java
    @EnableScheduling
    @SpringBootApplication
    @MapperScan("com.lyj.eblog.mapper")
    public class EblogApplication {
    
        public static void main(String[] args) {
            SpringApplication.run(EblogApplication.class, args);
            System.out.println("Test");
        }
    }
    
    ```

  - ViewCountSync.java

  - ```java
    package com.lyj.eblog.schedules;
    
    import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
    import com.lyj.eblog.pojo.Post;
    import com.lyj.eblog.service.IPostService;
    import com.lyj.eblog.util.RedisUtil;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.data.redis.core.RedisTemplate;
    import org.springframework.scheduling.annotation.Scheduled;
    import org.springframework.stereotype.Component;
    
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Set;
    
    
    /**
     * 定时器功能：将缓存中的文章阅读量同步到数据库
     */
    @Component
    public class ViewCountSync {
    
        @Autowired
        RedisUtil redisUtil;
    
        @Autowired
        RedisTemplate redisTemplate;
    
        @Autowired
        IPostService postService;
    
    
        @Scheduled(cron = "0/5 * * * * *") //每分钟同步
        public void task() {
    
            Set<String> keys = redisTemplate.keys("rank:post:*");
    
            List<String> ids = new ArrayList<>();
            for (String key : keys) {
                if(redisUtil.hHasKey(key, "post:viewCount")){
                    ids.add(key.substring("rank:post:".length()));
                }
            }
    
            if(ids.isEmpty()) return;
    
            // 需要更新阅读量
            List<Post> posts = postService.list(new QueryWrapper<Post>().in("id", ids));
    
            posts.stream().forEach((post) ->{
                Integer viewCount = (Integer) redisUtil.hget("rank:post:" + post.getId(), "post:viewCount");
                post.setViewCount(viewCount);
            });
    
            if(posts.isEmpty()) return;
    
            boolean isSuccess = postService.updateBatchById(posts);
    
            if(isSuccess) {
                ids.stream().forEach((id) -> {
                    redisUtil.hdel("rank:post:" + id, "post:viewCount");
                    System.out.println(id + "---------------------->同步成功");
                });
            }
        }
    }
    
    ```

![image-20220211174317013](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220211174317013.png)

![image-20220211174357769](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220211174357769.png)



## 4. 登录与注册

### 4.1 登录逻辑

关于登录模块，我们先来梳理一下逻辑，首先是把登录注册的页面复制进来，然后改成模板形式（头和尾，侧边栏等），再然后集成 shiro 框架，写登录注册接口，login -> realm(认证）-> 写登录注册逻辑 -> 页面的 shiro 标签 -> 分布式 session 的相关配置.

`LoginController`

```java
    @GetMapping("/login")
    public String login() {
        return "/auth/login";
    }

    @ResponseBody
    @PostMapping("/login")
    public Result doLogin(String email, String password) {
        if (StrUtil.isEmpty(email) || StrUtil.isBlank(password)) {
            return Result.fail("邮箱或密码不能为空");
        }

        UsernamePasswordToken token = new UsernamePasswordToken(email, SecureUtil.md5(password));
        try {
            SecurityUtils.getSubject().login(token);
        } catch (AuthenticationException e) {
            if (e instanceof UnknownAccountException) {
                return Result.fail("用户不存在");
            } else if (e instanceof LockedAccountException) {
                return Result.fail("用户被禁用");
            } else if (e instanceof IncorrectCredentialsException) {
                return Result.fail("密码错误");
            } else {
                return Result.fail("用户认证失败");
            }
        }

        return Result.success().action("/");
    }
```

上面的代码，首先分别写了一下 login 的 get 和 post 的方式，一个是跳转到 login，然后我们通过异步的 post 方式来提交 form 表单数据，login 的主要逻辑很简单，主要就一行代码：

```java
SecurityUtils.getSubject().login(token);

根据我们对shiro的理解，login之后会最终委托给realm完成登录逻辑的认证，那么我们先来看看realm的内容（doGetAuthenticationInfo）
    
@Slf4j
@Component
public class AccountRealm extends AuthorizingRealm {
    @Autowired
    UserService userService;
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        UsernamePasswordToken token = (UsernamePasswordToken)authenticationToken;
        //注意token.getUsername()是指email！！
        AccountProfile profile = userService.login(token.getUsername(), String.valueOf(token.getPassword()));
        log.info("---------------->进入认证步骤");
        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(profile, token.getCredentials(), getName());
        return info;
    }
}
```

`doGetAuthenticationInfo` 就是我们认证的方法，`authenticationToken` 就是我们的传过来的 `UsernamePasswordToken` ，包含着邮箱和密码。然后 `userService.login` 的内容就是校验一下账户的合法性，不合法就抛出对应的异常，合法最终就返回封装对象 `AccountProfile`。

```java
@Override
public AccountProfile login(String username, String password) {
    log.info("------------>进入用户登录判断，获取用户信息步骤");
    User user = this.getOne(new QueryWrapper<User>().eq("email", username));
    if(user == null) {
        throw new UnknownAccountException("账户不存在");
    }
    if(!user.getPassword().equals(password)) {
        throw new IncorrectCredentialsException("密码错误");
    }
    //更新最后登录时间
    user.setLasted(new Date());
    this.updateById(user);
    AccountProfile profile = new AccountProfile();
    BeanUtil.copyProperties(user, profile);
    return profile;
}
```


### 4.2 注册

注册过程设计到一个验证码校验的插件，这里我们使用 google 的验证码生成器 kaptcha。

1. 引入依赖

   ```xml
           <!--图像验证码-->
           <!-- https://mvnrepository.com/artifact/com.github.axet/kaptcha -->
           <dependency>
               <groupId>com.github.axet</groupId>
               <artifactId>kaptcha</artifactId>
               <version>0.0.9</version>
           </dependency>
   ```

2. 然后配置一下验证码的图片生成规则：（边框、颜色、字体大小、长、高等）

   ```java
   /**
    * 图形验证码配置类
    * */
   @Configuration
   public class KaptchaConfig {
       @Bean
       public DefaultKaptcha producer () {
           Properties propertis = new Properties();
           propertis.put("kaptcha.border", "no");
           propertis.put("kaptcha.image.height", "38");
           propertis.put("kaptcha.image.width", "150");
           propertis.put("kaptcha.textproducer.font.color", "black");
           propertis.put("kaptcha.textproducer.font.size", "32");
           Config config = new Config(propertis);
           DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
           defaultKaptcha.setConfig(config);
   
           return defaultKaptcha;
       }
   }
   ```

3. 提供一个访问的接口用于生成验证码图片

   ```java
       private static final String KAPTCHA_SESSION_KEY = "KAPTCHA_SESSION_KEY";
   
    @Autowired
       Producer producer;
   
       @GetMapping("/kapthca.jpg")
       public void kaptcha(HttpServletResponse response) throws IOException {
           /*验证码*/
           String text = producer.createText();
           BufferedImage image = producer.createImage(text);
   
           /*将验证码信息存储到Session中*/
           request.getSession().setAttribute(KAPTCHA_SESSION_KEY, text);
   
           response.setHeader("Cache-Control",
                   "no-store, no-cache");
           response.setContentType("image/ipeg");
           ServletOutputStream outputStream = response.getOutputStream();
           ImageIO.write(image, "jpg", outputStream);
       }
   ```
   
4. 所以访问这个接口就能得到验证码图片流，页面中：

   ```html
   <div class="">
       <image id="kapthca" src="/kapthca.jpg"></image>
   </div>
   
   ```

5. 那么流是接通前端后端的，到后端还需要验证验证码的正确性，所以生成验证码的时候我们需要把验证码先存到 session 中，然后注册接口中再从 session 中获取出来然后比较是否正确。

   ```java
       @ResponseBody
       @PostMapping("/register")
       public Result doRegister(User user, String repass, String vercode) {
   
           /*检验用户名、密码、邮箱*/
           ValidationUtil.ValidResult validResult = ValidationUtil.validateBean(user);
           if (validResult.hasErrors()) {
               return Result.fail(validResult.getErrors());
           }
   
           /**
            * 这里如果把密码加密应该更好一些
            * */
           if (!user.getPassword().equals(repass)) {
               return Result.fail("两次输入密码不正确");
           }
   
           /*图片验证码*/
           String attribute = (String) request.getSession().getAttribute(KAPTCHA_SESSION_KEY);
   
           if (attribute == null || !attribute.equalsIgnoreCase(vercode)) {
               return Result.fail("验证码输入不正确");
           }
   
           /*注册功能*/
           Result result = userService.register(user);
           return result.action("/login");
       }
   ```

6. 注册的逻辑

   ```java
       /*用户注册*/
       @Override
       public Result register(User user) {
           long count = this.count(new QueryWrapper<User>()
                   .eq("email", user.getEmail())
                   .or()
                   .eq("username", user.getUsername()));
           if (count > 0) {
               return Result.fail("邮箱或用户名已被占用");
           }
   
   /*新建一个User对象而不直接传过来的user原因在于代码只判断了email、username、password三项;
   * 不能确保F12修改代码传输其他的属性
   * */
           User temp = new User();
           temp.setUsername(user.getUsername());
           temp.setPassword(SecureUtil.md5(user.getPassword()));
           temp.setEmail(user.getEmail());
           temp.setAvatar("/res/images/avatar/default.png");
   
           temp.setCreated(new Date());
           temp.setPoint(0);
           temp.setVipLevel(0);
           temp.setCommentCount(0);
           temp.setPostCount(0);
           temp.setGender("0");
           this.save(temp);
   
           return Result.success();
       }
   ```

## 5.异常处理

使用  `@ControllerAdvice` 来进行统一异常处理，`@ExceptionHandler(value = Exception.class)` 来指定捕获的 `Exception` 各个类型异常 ，这个异常的处理，是全局的，所有类似的异常，都会跑到这个地方处理。

1. 我们自定义一个异常类 `HwException`，需要继承 `RuntimeException`，这样涉及到事务时候才会有回滚。`HwException` 将作为我们系统 `catch` 到错误时候报出来的异常。

   ```java
   public class HwException extends RuntimeException {
       private int code;
       public HwException() {}
       public HwException(int code) {
           this.code = code;
       }
       public HwException(String message) {
           super(message);
       }
       public HwException(int code, String message) {
           super(message);
           this.code = code;
       }
       public int getCode() {
           return code;
       }
       public void setCode(int code) {
           this.code = code;
       }
   }
   ```

2. 定义全局异常处理，`@ControllerAdvice` 表示定义全局控制器异常处理，`@ExceptionHandler` 表示针对性异常处理，可对每种异常针对性处理。

   ```java
   @Slf4j
   @ControllerAdvice
   public class GlobalExceptionHandler {
       @ExceptionHandler(value = Exception.class)
       public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) {
           log.error("------------------>捕捉到全局异常", e);
           if(e instanceof HwException) {
               //...
           }
           ModelAndView mav = new ModelAndView();
           mav.addObject("exception", e);
           mav.addObject("message", e.getMessage());
           mav.addObject("url", req.getRequestURL());
           mav.setViewName("error");
           return mav;
       }
       @ExceptionHandler(value = HwException.class)
       @ResponseBody
       public Result jsonErrorHandler(HttpServletRequest req, HwException e) {
           return Result.fail(e.getMessage(), "some error data");
       }
   }
   ```

## 6. 集成Redis

1. 引入 `Redis`

   ```xml
   <!--redis-->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-data-redis</artifactId>
   </dependency>
   ```

2. 配置 `Redis`

   ```yml
   spring:
     redis:
       host: localhost
       port: 6379
   ```

3. 为了让我们的存到 `Redis`中的缓存数据能更加容易看懂，这里换一种序列化方式，默认的是 `jdk` 的序列化方式，这里选用 `jackson2JsonRedisSerializer`。只需要重写 `redisTemplate` 操作模板的生成方式即可。

   ```java
   @Configuration
   public class RedisConfiguration {
       @Bean
       public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {
           RedisTemplate<Object, Object> template = new RedisTemplate();
           template.setConnectionFactory(redisConnectionFactory);
           Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
           jackson2JsonRedisSerializer.setObjectMapper(new ObjectMapper());
           template.setKeySerializer(jackson2JsonRedisSerializer);
           template.setValueSerializer(jackson2JsonRedisSerializer);
           return template;
       }
   }
   ```

4. 使用 `redisTemplate`  操作数据相对比较麻烦，我们使用一个 util 封装类，让我们操作 redis 更加方便。

   ```java
   package com.lyj.eblog.util;
   
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.data.redis.core.RedisTemplate;
   import org.springframework.data.redis.core.ZSetOperations;
   import org.springframework.stereotype.Component;
   import org.springframework.util.CollectionUtils;
   
   import java.util.Collection;
   import java.util.List;
   import java.util.Map;
   import java.util.Set;
   import java.util.concurrent.TimeUnit;
   
   @Component
   public class RedisUtil {
   
       @Autowired
       private RedisTemplate redisTemplate;
   
       /**
        * 指定缓存失效时间
        *
        * @param key  键
        * @param time 时间(秒)
        * @return
        */
       public boolean expire(String key, long time) {
           try {
               if (time > 0) {
                   redisTemplate.expire(key, time, TimeUnit.SECONDS);
               }
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 根据key 获取过期时间
        *
        * @param key 键 不能为null
        * @return 时间(秒) 返回0代表为永久有效
        */
       public long getExpire(String key) {
           return redisTemplate.getExpire(key, TimeUnit.SECONDS);
       }
   
       /**
        * 判断key是否存在
        *
        * @param key 键
        * @return true 存在 false不存在
        */
       public boolean hasKey(String key) {
           try {
               return redisTemplate.hasKey(key);
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 删除缓存
        *
        * @param key 可以传一个值 或多个
        */
       @SuppressWarnings("unchecked")
       public void del(String... key) {
           if (key != null && key.length > 0) {
               if (key.length == 1) {
                   redisTemplate.delete(key[0]);
               } else {
                   redisTemplate.delete(CollectionUtils.arrayToList(key));
               }
           }
       }
   
       //============================String=============================  
   
       /**
        * 普通缓存获取
        *
        * @param key 键
        * @return 值
        */
       public Object get(String key) {
           return key == null ? null : redisTemplate.opsForValue().get(key);
       }
   
       /**
        * 普通缓存放入
        *
        * @param key   键
        * @param value 值
        * @return true成功 false失败
        */
       public boolean set(String key, Object value) {
           try {
               redisTemplate.opsForValue().set(key, value);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
   
       }
   
       /**
        * 普通缓存放入并设置时间
        *
        * @param key   键
        * @param value 值
        * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
        * @return true成功 false 失败
        */
       public boolean set(String key, Object value, long time) {
           try {
               if (time > 0) {
                   redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
               } else {
                   set(key, value);
               }
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 递增
        *
        * @param key 键
        * @param delta  要增加几(大于0)
        * @return
        */
       public long incr(String key, long delta) {
           if (delta < 0) {
               throw new RuntimeException("递增因子必须大于0");
           }
           return redisTemplate.opsForValue().increment(key, delta);
       }
   
       /**
        * 递减
        *
        * @param key 键
        * @param delta  要减少几(小于0)
        * @return
        */
       public long decr(String key, long delta) {
           if (delta < 0) {
               throw new RuntimeException("递减因子必须大于0");
           }
           return redisTemplate.opsForValue().increment(key, -delta);
       }
   
       //================================Map=================================  
   
       /**
        * HashGet
        *
        * @param key  键 不能为null
        * @param item 项 不能为null
        * @return 值
        */
       public Object hget(String key, String item) {
           return redisTemplate.opsForHash().get(key, item);
       }
   
       /**
        * 获取hashKey对应的所有键值
        *
        * @param key 键
        * @return 对应的多个键值
        */
       public Map<Object, Object> hmget(String key) {
           return redisTemplate.opsForHash().entries(key);
       }
   
       /**
        * HashSet
        *
        * @param key 键
        * @param map 对应多个键值
        * @return true 成功 false 失败
        */
       public boolean hmset(String key, Map<String, Object> map) {
           try {
               redisTemplate.opsForHash().putAll(key, map);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * HashSet 并设置时间
        *
        * @param key  键
        * @param map  对应多个键值
        * @param time 时间(秒)
        * @return true成功 false失败
        */
       public boolean hmset(String key, Map<String, Object> map, long time) {
           try {
               redisTemplate.opsForHash().putAll(key, map);
               if (time > 0) {
                   expire(key, time);
               }
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 向一张hash表中放入数据,如果不存在将创建
        *
        * @param key   键
        * @param item  项
        * @param value 值
        * @return true 成功 false失败
        */
       public boolean hset(String key, String item, Object value) {
           try {
               redisTemplate.opsForHash().put(key, item, value);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 向一张hash表中放入数据,如果不存在将创建
        *
        * @param key   键
        * @param item  项
        * @param value 值
        * @param time  时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间
        * @return true 成功 false失败
        */
       public boolean hset(String key, String item, Object value, long time) {
           try {
               redisTemplate.opsForHash().put(key, item, value);
               if (time > 0) {
                   expire(key, time);
               }
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 删除hash表中的值
        *
        * @param key  键 不能为null
        * @param item 项 可以使多个 不能为null
        */
       public void hdel(String key, Object... item) {
           redisTemplate.opsForHash().delete(key, item);
       }
   
       /**
        * 判断hash表中是否有该项的值
        *
        * @param key  键 不能为null
        * @param item 项 不能为null
        * @return true 存在 false不存在
        */
       public boolean hHasKey(String key, String item) {
           return redisTemplate.opsForHash().hasKey(key, item);
       }
   
       /**
        * hash递增 如果不存在,就会创建一个 并把新增后的值返回
        *
        * @param key  键
        * @param item 项
        * @param by   要增加几(大于0)
        * @return
        */
       public double hincr(String key, String item, double by) {
           return redisTemplate.opsForHash().increment(key, item, by);
       }
   
       /**
        * hash递减
        *
        * @param key  键
        * @param item 项
        * @param by   要减少记(小于0)
        * @return
        */
       public double hdecr(String key, String item, double by) {
           return redisTemplate.opsForHash().increment(key, item, -by);
       }
   
       //============================set=============================  
   
       /**
        * 根据key获取Set中的所有值
        *
        * @param key 键
        * @return
        */
       public Set<Object> sGet(String key) {
           try {
               return redisTemplate.opsForSet().members(key);
           } catch (Exception e) {
               e.printStackTrace();
               return null;
           }
       }
   
       /**
        * 根据value从一个set中查询,是否存在
        *
        * @param key   键
        * @param value 值
        * @return true 存在 false不存在
        */
       public boolean sHasKey(String key, Object value) {
           try {
               return redisTemplate.opsForSet().isMember(key, value);
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 将数据放入set缓存
        *
        * @param key    键
        * @param values 值 可以是多个
        * @return 成功个数
        */
       public long sSet(String key, Object... values) {
           try {
               return redisTemplate.opsForSet().add(key, values);
           } catch (Exception e) {
               e.printStackTrace();
               return 0;
           }
       }
   
       /**
        * 将set数据放入缓存
        *
        * @param key    键
        * @param time   时间(秒)
        * @param values 值 可以是多个
        * @return 成功个数
        */
       public long sSetAndTime(String key, long time, Object... values) {
           try {
               Long count = redisTemplate.opsForSet().add(key, values);
               if (time > 0) expire(key, time);
               return count;
           } catch (Exception e) {
               e.printStackTrace();
               return 0;
           }
       }
   
       /**
        * 获取set缓存的长度
        *
        * @param key 键
        * @return
        */
       public long sGetSetSize(String key) {
           try {
               return redisTemplate.opsForSet().size(key);
           } catch (Exception e) {
               e.printStackTrace();
               return 0;
           }
       }
   
       /**
        * 移除值为value的
        *
        * @param key    键
        * @param values 值 可以是多个
        * @return 移除的个数
        */
       public long setRemove(String key, Object... values) {
           try {
               Long count = redisTemplate.opsForSet().remove(key, values);
               return count;
           } catch (Exception e) {
               e.printStackTrace();
               return 0;
           }
       }
       //===============================list=================================  
   
       /**
        * 获取list缓存的内容
        *
        * @param key   键
        * @param start 开始
        * @param end   结束  0 到 -1代表所有值
        * @return
        */
       public List<Object> lGet(String key, long start, long end) {
           try {
               return redisTemplate.opsForList().range(key, start, end);
           } catch (Exception e) {
               e.printStackTrace();
               return null;
           }
       }
   
       /**
        * 获取list缓存的长度
        *
        * @param key 键
        * @return
        */
       public long lGetListSize(String key) {
           try {
               return redisTemplate.opsForList().size(key);
           } catch (Exception e) {
               e.printStackTrace();
               return 0;
           }
       }
   
       /**
        * 通过索引 获取list中的值
        *
        * @param key   键
        * @param index 索引  index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推
        * @return
        */
       public Object lGetIndex(String key, long index) {
           try {
               return redisTemplate.opsForList().index(key, index);
           } catch (Exception e) {
               e.printStackTrace();
               return null;
           }
       }
   
       /**
        * 将list放入缓存
        *
        * @param key   键
        * @param value 值
        * @return
        */
       public boolean lSet(String key, Object value) {
           try {
               redisTemplate.opsForList().rightPush(key, value);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 将list放入缓存
        *
        * @param key   键
        * @param value 值
        * @param time  时间(秒)
        * @return
        */
       public boolean lSet(String key, Object value, long time) {
           try {
               redisTemplate.opsForList().rightPush(key, value);
               if (time > 0) expire(key, time);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 将list放入缓存
        *
        * @param key   键
        * @param value 值
        * @return
        */
       public boolean lSet(String key, List<Object> value) {
           try {
               redisTemplate.opsForList().rightPushAll(key, value);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 将list放入缓存
        *
        * @param key   键
        * @param value 值
        * @param time  时间(秒)
        * @return
        */
       public boolean lSet(String key, List<Object> value, long time) {
           try {
               redisTemplate.opsForList().rightPushAll(key, value);
               if (time > 0) expire(key, time);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 根据索引修改list中的某条数据
        *
        * @param key   键
        * @param index 索引
        * @param value 值
        * @return
        */
       public boolean lUpdateIndex(String key, long index, Object value) {
           try {
               redisTemplate.opsForList().set(key, index, value);
               return true;
           } catch (Exception e) {
               e.printStackTrace();
               return false;
           }
       }
   
       /**
        * 移除N个值为value
        *
        * @param key   键
        * @param count 移除多少个
        * @param value 值
        * @return 移除的个数
        */
       public long lRemove(String key, long count, Object value) {
           try {
               Long remove = redisTemplate.opsForList().remove(key, count, value);
               return remove;
           } catch (Exception e) {
               e.printStackTrace();
               return 0;
           }
       }
   
       //================有序集合 sort set===================
       /**
        * 有序set添加元素
        *
        * @param key
        * @param value
        * @param score
        * @return
        */
       public boolean zSet(String key, Object value, double score) {
           return redisTemplate.opsForZSet().add(key, value, score);
       }
   
       public long batchZSet(String key, Set<ZSetOperations.TypedTuple> typles) {
           return redisTemplate.opsForZSet().add(key, typles);
       }
   
       public void zIncrementScore(String key, Object value, long delta) {
           redisTemplate.opsForZSet().incrementScore(key, value, delta);
       }
   
       public void zUnionAndStore(String key, Collection otherKeys, String destKey) {
           redisTemplate.opsForZSet().unionAndStore(key, otherKeys, destKey);
       }
   
       /**
        * 获取zset数量
        * @param key
        * @param value
        * @return
        */
       public long getZsetScore(String key, Object value) {
           Double score = redisTemplate.opsForZSet().score(key, value);
           if(score==null){
               return 0;
           }else{
               return score.longValue();
           }
       }
   
       /**
        * 获取有序集 key 中成员 member 的排名 。
        * 其中有序集成员按 score 值递减 (从大到小) 排序。
        * @param key
        * @param start
        * @param end
        * @return
        */
       public Set<ZSetOperations.TypedTuple> getZSetRank(String key, long start, long end) {
           return redisTemplate.opsForZSet().reverseRangeWithScores(key, start, end);
       }
   
   }
   ```

   

   

![image-20220213224039587](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220213224039587.png)