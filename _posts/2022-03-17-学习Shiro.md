# Shiro

## 1. 权限的管理

### 1.1 什么是权限管理

​		基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现对 `用户访问系统的控制`，按照安全规则或者[安全策略](http://baike.baidu.com/view/160028.htm)控制 `用户可以访问而且只能访问自己被授权` 的资源。

​		权限管理包括用户`身份认证`和`授权`两部分，简称`认证授权`。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。

### 1.2 什么是身份认证

​		`身份认证`，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用[指纹](http://baike.baidu.com/view/5628.htm)等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。

### 1.3 什么是授权

​		`授权，即访问控制`，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的

## 2. 什么是Shiro

​		Apache Shiro™ is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.

​		Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。

> **`Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。`**

## 3. Shiro的核心架构

![Shiro Architecture Diagram](https://shiro.apache.org/images/ShiroArchitecture.png)



### 3.1 Subject

​		**`Subject`即主体**，外部应用与 `subject` 进行交互，`subject` 记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。`Subject` 在 `shiro` 中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过 `subject` 进行认证授权，而 `subject` 是通过`SecurityManager` 安全管理器进行认证授权。

### 3.2 SecurityManager

​		**`SecurityManager` 即安全管理器**，对全部的 `subject` 进行安全管理，它是 `shiro` 的**核心**，负责对所有的`subject` 进行安全管理。通过 `SecurityManager` 可以完成 `subject` 的认证、授权等，实质上 `SecurityManager` 是通过 `Authenticator` 进行认证，通过 `Authorizer` 进行授权，通过 `SessionManager` 进行会话管理等。

**`SecurityManager` 是一个接口，继承了 `Authenticator`,  `Authorizer`,  `SessionManager`这三个接口。**

### 3.3 Authenticator

​		**`Authenticator`即认证器**，对用户身份进行认证，`Authenticator` 是一个接口，`shiro` 提供`ModularRealmAuthenticator` 实现类，通过 `ModularRealmAuthenticator` 基本上可以满足大多数需求，也可以自定义认证器。

### 3.4 Authorizer

​		**`Authorizer`即授权器**，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。

### 3.5 Realm

​		**`Realm`即领域**，相当于 `datasource` 数据源，`SecurityManager` 进行安全认证需要通过 `Realm` 获取用户权限数据，比如：如果用户身份数据在数据库那么 `realm` 就需要从数据库获取用户身份信息。

- 不要把 `realm` 理解成只是从数据源取数据，在 `realm` 中还有认证授权校验的相关的代码。

### 3.6 SessionManager

​		**`SessionManager`即会话管理**，`shiro` 框架定义了一套会话管理，它不依赖 `web` 容器的 `session`，所以`shiro` 可以使用在非 `web` 应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。

### 3.7 SessionDAO

**`SessionDAO`即会话dao**，是对 `session` 会话操作的一套接口，比如要将 `session` 存储到数据库，可以通过`jdbc` 将会话存储到数据库。

### 3.8 CacheManager

**`CacheManager`即缓存管理**，将用户权限数据存储在缓存，这样可以提高性能

###  3.9 Cryptography

**`Cryptography`即密码管理**，`shiro` 提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。

## 4. Shiro认证

### 4.1 认证

​		身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。

### 4.2 Shiro中认证的关键对象

- **`Subject`：主体**
  - 访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体；
- **`Principal`：身份信息**
  - 是主体（subject）进行身份认证的标识，标识必须具有 **`唯一性`**，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。
- **`credential`：凭证信息**
  - 是只有主体自己知道的安全信息，如密码、证书等。

### 4.3 认证流程

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/c525acf54f0ed950d6da0b848fba8f7f.png)

### 4.4 认证的开发

#### 4.4.1 创建项目并引入依赖

```xml
        <dependency>
            <groupId>org.apache.shiro</groupId>
            <artifactId>shiro-core</artifactId>
            <version>1.5.3</version>
        </dependency>
```

#### 4.4.2 引入Shiro配置文件并加入以下配置

配置文件：名称随意，以 `.ini` 结尾，放在 `resources` 目录下

**注意**：在实际的项目开发中并不会使用这种方式，这种方法可以用来初学时练手，可以把权限相关的数据写在 `.ini` 文件中。

```ini
[users]
zhangsan=123456
lisi=456789
```

#### 4.4.3 开发认证代码

```java
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.mgt.DefaultSecurityManager;
import org.apache.shiro.mgt.SecurityManager;
import org.apache.shiro.realm.text.IniRealm;
import org.apache.shiro.subject.Subject;

public class testAuthenticator {
    public static void main(String[] args) {
        // 1.创建安全管理器对象
        DefaultSecurityManager manager = new DefaultSecurityManager();
        // 2. 给安全管理器设置realm
        manager.setRealm(new IniRealm("classpath:shiro.ini"));
        // 3. SecurityUtils给全局安全工具类设置安全管理器
        SecurityUtils.setSecurityManager(manager);
        // 4. 关键对象subject主体
        Subject subject = SecurityUtils.getSubject();
        // 5. 创建令牌
        UsernamePasswordToken token = new UsernamePasswordToken("lisi", "456789");
        try {
            System.out.println("认证状态" + subject.isAuthenticated()); // false
            //用户认证
            subject.login(token);
            System.out.println("认证状态" + subject.isAuthenticated()); // true
        } catch (UnknownAccountException e) {
            e.printStackTrace();
            System.out.println("认证失败，用户名不存在");
        } catch (IncorrectCredentialsException e) {
            e.printStackTrace();
            System.out.println("认证失败，密码错误");
        }
    }
}
```

### 4.5 常见的异常类型

- `DisabledAccountException`（帐号被禁用）
- `LockedAccountException`（帐号被锁定）
- `ExcessiveAttemptsException`（登录失败次数过多）
- `ExpiredCredentialsException`（凭证过期）等

### 4.6 源码分析与自定义Realm

```markdown
**
认证：
1. 最终执行用户名比较是 在SimpleAccountRealm类 的 doGetAuthenticationInfo 方法中完成用户名校验
2. 最终密码校验是在 AuthenticatingRealm类 的 assertCredentialsMatch方法 中
****
总结：
> AuthenticatingRealm 认证  realm doGetAuthenticationInf
> AuthorizingRealm    授权  realm doGetAuthorizationInfo
**
```

上边的程序使用的是 `Shiro` 自带的 `IniRealm`，`IniRealm` 从 `ini` 配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义 `realm`。

1. **源码分析**

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/aec0096cd637ac6df43f8212e3ff95b3.png)

**根据认证源码认证使用的是 `SimpleAccountRealm`**

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/e9229269698a66b32a74812fa6ddaa7d.png)

`SimpleAccountRealm`的部分源码中有两个方法，一个是认证 一个是 授权：

```java
public class SimpleAccountRealm extends AuthorizingRealm {
		//.......省略
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        UsernamePasswordToken upToken = (UsernamePasswordToken) token;
        SimpleAccount account = getUser(upToken.getUsername());

        if (account != null) {

            if (account.isLocked()) {
                throw new LockedAccountException("Account [" + account + "] is locked.");
            }
            if (account.isCredentialsExpired()) {
                String msg = "The credentials for account [" + account + "] are expired";
                throw new ExpiredCredentialsException(msg);
            }

        }

        return account;
    }

    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        String username = getUsername(principals);
        USERS_LOCK.readLock().lock();
        try {
            return this.users.get(username);
        } finally {
            USERS_LOCK.readLock().unlock();
        }
    }
}
```

2. **自定义Realm**

自定义 `Realm` 的作用：放弃使用 `.ini` 文件，使用数据库查询。

```java
package realm;

import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

/**
 * 自定义Realm实现 将认证/授权数据得来源转为数据库的实现
 */
public class customerRealm extends AuthorizingRealm {
    // 授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    // 认账
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 从token中获取用户名
        String principal = (String) authenticationToken.getPrincipal();
        System.out.println("=====================================");
        System.out.println(principal);
        System.out.println("=====================================");

        //实际开发中应当 根据身份信息使用jdbc mybatis查询相关数据库
        //在这里只做简单的演示
        //假设username,password是从数据库获得的信息
        String username = "zhangsan";
        String password = "123456";
        if (username.equals(principal)) {
            //参数1:返回数据库中正确的用户名
            //参数2:返回数据库中正确密码
            //参数3:提供当前realm的名字 this.getName();
            SimpleAuthenticationInfo simpleAuthenticationInfo =
                    new SimpleAuthenticationInfo(principal, password, this.getName());
            return simpleAuthenticationInfo;
        }
        return null;
    }
}
```

3. 使用自定义 `Realm` 认证

```java
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.IncorrectCredentialsException;
import org.apache.shiro.authc.UnknownAccountException;
import org.apache.shiro.authc.UsernamePasswordToken;
import org.apache.shiro.mgt.DefaultSecurityManager;
import org.apache.shiro.subject.Subject;
import realm.customerRealm;

/**
 * 测试自定义的Realm
 */
public class testCustomerRealm {
    public static void main(String[] args) {
        DefaultSecurityManager manager = new DefaultSecurityManager();
        manager.setRealm(new customerRealm());
        SecurityUtils.setSecurityManager(manager);
        Subject subject = SecurityUtils.getSubject();
        UsernamePasswordToken token = new UsernamePasswordToken("zhangsan", "123456");
        try {
            subject.login(token);//用户登录
            System.out.println("登录成功~~");
        } catch (UnknownAccountException e) {
            e.printStackTrace();
            System.out.println("用户名错误!!");
        }catch (IncorrectCredentialsException e){
            e.printStackTrace();
            System.out.println("密码错误!!!");
        }
    }
}
```

```java
=====================================
zhangsan
=====================================
登录成功~~
```

### 4.7 使用MD5+Salt

> 实际应用是将盐和散列后得值存在数据库中，自动 `realm` 从数据库中取出盐和加密后得值由 `shiro` 完成密码校验。

**补充：MD5算法**

作用：一般用来加密或者签名（校验和）

特点：MD5算法不可逆；如果内容相同无论执行多少次md5生成结果始终是一致。

网络上提供的MD5在线解密一般是用穷举的方法

生成结果：始终是一个16进制32位长度字符串



#### 4.7.0 Shiro中的md5加密

```java
import org.apache.shiro.crypto.hash.Md5Hash;

public class testShiroMD5 {
    public static void main(String[] args) {

        // 使用md5算法
        Md5Hash md5Hash = new Md5Hash("123");
        System.out.println(md5Hash.toHex()); // 202cb962ac59075b964b07152d234b70

        // 使用md5 + Salt
        Md5Hash md5Hash1 = new Md5Hash("123", "X0*7ps");
        System.out.println(md5Hash1.toHex()); // 8a83592a02263bfe6752b2b5b03a4799

        // //使用md5 + salt + hash散列(参数代表要散列多少次，一般是 1024或2048)
        Md5Hash md5Hash2 = new Md5Hash("123", "X0*7ps", 1024);
        System.out.println(md5Hash2.toHex()); // e4f9bf3e0c58f045e62c23c533fcf633
    }
}
```

```java
import org.apache.shiro.crypto.hash.Md5Hash;

public class testShiroMD5 {
    public static void main(String[] args) {

        // 创建md5算法
//        Md5Hash md5Hash = new Md5Hash();
//        md5Hash.setBytes("123".getBytes());
//        String s = md5Hash.toHex();
//        System.out.println(s); // 313233

        // 使用md5算法
        Md5Hash md5Hash = new Md5Hash("123");
        System.out.println(md5Hash.toHex()); // 202cb962ac59075b964b07152d234b70

        // 使用md5 + Salt
        Md5Hash md5Hash1 = new Md5Hash("123", "X0*7ps");
        System.out.println(md5Hash1.toHex()); // 8a83592a02263bfe6752b2b5b03a4799

        // //使用md5 + salt + hash散列(参数代表要散列多少次，一般是 1024或2048)
        Md5Hash md5Hash2 = new Md5Hash("123", "X0*7ps", 1024);
        System.out.println(md5Hash2.toHex()); // e4f9bf3e0c58f045e62c23c533fcf633
    }
}

```

```java
202cb962ac59075b964b07152d234b70
8a83592a02263bfe6752b2b5b03a4799
e4f9bf3e0c58f045e62c23c533fcf633
```



#### 4.7.1 自定义md5+salt的realm







```java

```





## 5. Shiro授权