# 学习Vue.js

## 0. ES6补充

### 0.1 `var` 没有块级作用域

> 在 `if` 和 `for` 中会出错

```html
<script>
    {
        var name = 'Hello Vue';
        console.log(name);
    }
    console.log(name);
</script>
```

![image-20220301165743759](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301165743759.png)

```html
<button>按钮1</button>
<button>按钮2</button>
<button>按钮3</button>
<button>按钮4</button>
<button>按钮5</button>
<script>
    var btns = document.getElementsByTagName("button");
    for (var i =0;i<btns.length;++i) {
        btns[i].addEventListener('click', function () {
            console.log('第' + i + '个按钮被点击')
        })
    }
</script>
```

![image-20220301182223932](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301182223932.png)

### 0.2 `const` 的使用

- 使用 `const` 修饰的标识符为常量, 不可以再次赋值.
- 当我们修饰的标识符不会被再次赋值时, 就可以使用 `const` 来保证数据的安全性.
- **建议： 在ES6开发中优先使用 `const`, 只有需要改变某一个标识符的时候才使用 `let.`** 

- ![image-20220301192236087](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301192236087.png)
- ![image-20220301192325647](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301192325647.png)
- ![image-20220301192547339](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301192547339.png)

### 0.3 `ES6` 对象字面量增强写法

1. 属性的增强写法

   ```json
       // 1. 属性的增强写法
       const name = 'why';
       const age = 18;
       const height = 1.88;
   
       // ES5的写法
       const  obj1 = {
           name: name,
           age: age,
           height: height,
       }
   
       // ES6的写法
       const onj2 = {
           name, age, height
       }
   ```

2. 方法的属性增强

   ```json
       /*2. 方法的属性增强*/
       // ES5的写法
       const ob1 = {
           run: function () {
   
           }
       }
   
       // ES6的写法
       const ob2 = {
           run() {
               
           }
       }
   ```

## 1. 介绍

Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。

- 渐进式意味着可以将 Vue 作为应用的一部分嵌入其中，带来更丰富的交互体验。

## 2. Vue.js初体验

### 2.1 第一个Vue.js程序

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<div id="app">{{message}}</div>

<body>
<script src="../js/vue.js"></script>
<script>
    // let定义变量 const定义常量
    // 编程范式：声明式编程
    /*好处：数据与界面完全分离*/
    let app = new Vue({
        el: '#app', // 定义要挂载的元素
        data: { // 定义数据
            message: 'Hello Vue.js',
        }
    })
</script>
</body>
</html>
```

![image-20220227170229059](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220227170229059.png)

### 2.2 Vue列表的展示

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<div id="app">
    <p>{{message}}</p>
    <ul>
        <li v-for="movie in movies">{{movie}}</li>
    </ul>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            message: 'Hello Vue.js',
            movies: ['星际穿越', '大话西游', '少年派', '盗梦空间'],
        }
    })
</script>

</body>
</html>
```

![image-20220227212250428](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220227212250428.png)

### 2.3 计数器

- 实现功能：小的计数器
  - 点击 `+` 计数器加1
  - 点击 `-` 计数器减1

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<div id="app">
    <h2>当前记数: {{counter}}</h2>
    <!--方法一：-->
<!--    <button v-on:click="++counter">+</button>
    <button v-on:click="&#45;&#45;counter">-</button>-->
    <!--方法二：-->
    <button v-on:click="add"></button>
    <button v-on:click="sub"></button>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            counter: 0,
        },
        methods: {
            add: function () {
                console.log("add被执行");
                this.counter++;
            },
            sub: function () {
                console.log("sub被执行");
                this.counter--;
            }
        }
    })
</script>

</body>
</html>
```

![image-20220227213529130](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220227213529130.png)

## 3. Vue中的MVVM

### 3.1 什么是MVVM

`MVVM` 是 `Model–view–viewmodel`的缩写，是一种软件[架构模式](https://zh.wikipedia.org/wiki/架构模式)。 

`MVVM` 有助于将 图形用户界面 的开发与 业务逻辑 或 后端逻辑（*数据模型*）的开发开来，这是通过 置标语言 或GUI代码实现的。`MVVM` 的*视图模型*是一个值转换器，这意味着视图模型负责从模型中暴露（转换） 数据对象 ，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现 中介者模式 ，组织对视图所支持的 用例 集的后端逻辑的访问。

- 模型
  - 模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。
- 视图
  - 就像在 `MVC` 和 `MVP` 模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）
- 视图模型
  - 视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。
- 绑定器
  - 声明性数据和命令绑定隐含在 `MVVM` 模式中。在Microsoft解决方案堆中，绑定器是一种名为 `XAML` 的标记语言。 绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。

### 3.2 Vue中的MVVM



## 4. Vue的生命周期

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/lifecycle.png)

可以看到在 `vue` 整个生命周期中会有很多 **钩子函数 **提供给我们在 `vue` 生命周期不同的时刻进行操作：

- **beforeCreate**
- **created**
- **beforeMount**
- **mounted**
- **beforeUpdate**
- **updated**
- **beforeDestroy**
- **destroyed**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue生命周期学习</title>
  <script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"></script>
</head>
<body>
  <div id="app">
    <h1>{{message}}</h1>
  </div>
</body>
<script>
  var vm = new Vue({
    el: '#app',
    data: {
      message: 'Vue的生命周期'
    },
    beforeCreate: function() {
      console.group('------beforeCreate创建前状态------');
      console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined
      console.log("%c%s", "color:red","data   : " + this.$data); //undefined 
      console.log("%c%s", "color:red","message: " + this.message) 
    },
    created: function() {
      console.group('------created创建完毕状态------');
      console.log("%c%s", "color:red","el     : " + this.$el); //undefined
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化 
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化
    },
    beforeMount: function() {
      console.group('------beforeMount挂载前状态------');
      console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化
      console.log(this.$el);
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化  
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化  
    },
    mounted: function() {
      console.group('------mounted 挂载结束状态------');
      console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化
      console.log(this.$el);    
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化 
    },
    beforeUpdate: function () {
      console.group('beforeUpdate 更新前状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el);   
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message); 
    },
    updated: function () {
      console.group('updated 更新完成状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el); 
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message); 
    },
    beforeDestroy: function () {
      console.group('beforeDestroy 销毁前状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el);    
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message); 
    },
    destroyed: function () {
      console.group('destroyed 销毁完成状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el);  
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message)
    }
  })
</script>
</html>
```

![image-20220228181528411](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228181528411.png)

1. ##### **在 `beforeCreate` 和 `created` 钩子函数之间的生命周期**

   - 在这个生命周期之间，进行**初始化事件，进行数据的观测**，可以看到在 **`created`** 的时候数据已经和 **`data` 属性进行绑定**（放在 `data` 中的属性当值发生改变的同时，视图也会改变）。
   - 注意看下：此时还是没有 `el` 选项

2. ##### **`created`钩子函数和 `beforeMount`间的生命周期**

   - 首先会判断对象是否有**el选项**。**如果有的话就继续向下编译，如果没有**el选项**，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。**

     - 如果注释掉代码 `el: '#app'`, 运行可以到 `created` 的时候就停止了：

     - ![img](https://segmentfault.com/img/bVVUB3/view?w=764&h=285)

     - 如果我们在后面继续调用 `vm.$mount(el)`, 可以发现代码继续向下执行了

     - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUCG)

     - 我们往下看，**`template`** 参数选项的有无对生命周期的影响。

       - 如果 `vue` 实例对象中有 `template` 参数选项，则将其作为模板编译成 `render` 函数。

       - 如果没有 `template` 选项，则将外部 `HTML` 作为模板编译。

       - 可以看到 `template` 中的模板优先级要高于 `outer HTML` 的优先级。

       - 举例：在HTML结构中增加了一串html，在vue对象中增加了**template选项**：

       - ```java
         <!DOCTYPE html>
         <html lang="en">
         <head>
           <meta charset="UTF-8">
           <meta name="viewport" content="width=device-width, initial-scale=1.0">
           <meta http-equiv="X-UA-Compatible" content="ie=edge">
           <title>vue生命周期学习</title>
           <script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"></script>
         </head>
         <body>
           <div id="app">
             <!--html中修改的-->
             <h1>{{message + '这是在outer HTML中的'}}</h1>
           </div>
         </body>
         <script>
           var vm = new Vue({
             el: '#app',
             template: "<h1>{{message +'这是在template中的'}}</h1>", //在vue配置项中修改的
             data: {
               message: 'Vue的生命周期'
             }
         </script>
         </html>
         ```

       - 执行后的结果可以看到在页面中显示的是：

       - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUJT)

       - 将 `vue` 对象中 `template` 的选项注释掉后打印如下信息：

       - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUJ3)

       - 在vue对象中还有一个**render函数**，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.

       - ```java
         new Vue({
             el: '#app',
             render: function(createElement) {
                 return createElement('h1', 'this is createElement')
             }
         })
         ```

       - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUSo)

     - 所以综合排名优先级：`render` 函数选项 > `template` 选项 > o`uter HTML`.

3. ##### **`beforeMount` 和 `mounted`  钩子函数间的生命周期**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUTK)
   - 给 `vue` 实例对象添加 **`el成员`**，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到 **`beforeMount` **之前 `el` 上还是 `undefined`。

4. ##### **`mounted`**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUYC)
   - 在 `mounted` 之前 `h1` 中还是通过  **`{{message}}`**进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在 `mounted` 之后可以看到 `h1` 中的内容发生了变化

5. ##### **`beforeUpdate` 钩子函数和 `updated` 钩子函数间的生命周期**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVU0E)
   - 当vue发现data中的数据发生了改变，会**触发对应组件的重新渲染**，先后调用**beforeUpdate**和**updated**钩子函数。我们在console中输入 `vm.message = '触发组件更新'`
   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVU55)

6. ##### **`beforeDestroy` 和 `destroyed` 钩子函数间的生命周期**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVU6C)
   - **`beforeDestroy`**钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。
   - **`destroyed`**钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁



## 5. Vue基础语法

### 5.1 Mustache语法

`Mustache` 语法即 `Vue` 中的 `{{ }}` 语法。

![image-20220228162835910](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228162835910.png)

### 5.2 v-once指令

> - 该指令后不需要跟任何表达式
> - 该指令表示元素和组件只渲染一次，不会随着数据的改变而改变。

```html
<div id="app">
    <h2>{{ message }}</h2>
    <h2 v-once>{{ message }}</h2>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            counter: 0,
            message: ' Hello Vue,js',
            firstName: 'kobe',
            lastName: 'bryant',
        },
        methods: {
            add: function () {
                console.log("add被执行");
                this.counter++;
            },
            sub: function () {
                console.log("sub被执行");
                this.counter--;
            }
        }
    })
</script>
```

![image-20220228163236610](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228163236610.png)

### 5.3 v-html指令

> 解析带有 `html` 标签的字符串 `v-html=""`

![image-20220228184820786](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228184820786.png)

### 5.4 v-text指令

`v-text` 指令的作用与 `Mustache` 相似，都是用于将数据显示在界面中。

接收的数据类型为 `string`。

![image-20220228185237906](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228185237906.png)

### 5.5 v-pr指令

> 不解析 `{{}}` 内部的语句

![image-20220228192629843](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228192629843.png)

### 5.6 v-cloak指令

> - 在 `vue` 解析之前，`div` 中存在属性 `v-clock`
> - 在 `vue` 解析之后，`div` 中没有属性 `v-clock`

### 5.7 v-bind指令

> 作用：动态绑定属性
>
> - 例如动态绑定 `a` 元素的 `href` 属性；
> - 例如动态绑定 `img` 元素的 `src` 属性；
>
> 可以使用 `:` 代替 `v-bind`。

#### 5.7.1 v-bind简单使用

![image-20220228195241621](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228195241621.png)

#### 5.7.2 v-bind动态绑定class

- 对象语法

  - ![image-20220228202527463](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228202527463.png)
  - ![image-20220228203514707](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228203514707.png)

- 数组语法

  - ```html
    <div id="app">
        <h2 class="title" :class="['active', 'line']">{{message}}</h2>
    </div>
    ```

  - ![image-20220228203813692](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228203813692.png)

#### 5.8.3 v-bind动态绑定style

> 对象语法

```html
<div id="app">
<!--    <h2 :style="{属性名:属性值}">{{message}}</h2>-->

    <!--'0px'必须加上单引号 否则是当作变量去解析
    驼峰标识的时候 fontSize 不需要加单引号
    -标识的时候 'font-size'也需要加单引号
    -->
    <h2 :style="{fontSize: '50px'}">{{message}}</h2>
    <h2 :style="{'font-size': '50px'}">{{message}}</h2>
    <h2 :style="{fontSize: size}">{{message}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            message: '你好呀',
            size: '100px'
        },
    })
```

![image-20220301150004990](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301150004990.png)

> 数组语法

![image-20220301150353552](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301150353552.png)

## 6. 计算属性

### 6.1 计算属性的简单操作

> `computed` 类似于 `methods`

```html
<div id="app">
    <h2>{{firstName + ' ' + lastName}}</h2>
    <h2>{{firstName}} {{lastName}}</h2>
    <h2>{{getFullName()}}</h2>
    <!--计算属性-->
    <h2>{{fullName}}</h2>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            firstName: '刘',
            lastName: '撷思',
        },
        /*计算属性*/
        computed: {
            fullName: function () {
                return this.firstName + ' ' + this.lastName;

            }
        },
        methods: {
            getFullName: function () {
                return this.firstName + ' ' + this.lastName;
            }
        }
    })
</script>
```

![image-20220301152057665](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301152057665.png)

### 6.2 计算属性的复杂操作

```html
<div id="app">
    <h2>总价格: {{totalPrice1}}</h2>
    <h2>总价格: {{totalPrice2}}</h2>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            books: [
                {id: 110, name: '深入理解计算机原理', price: 100},
                {id: 111, name: '现代操作系统', price: 105},
                {id: 112, name: '深入理解Java虚拟机', price: 110},
            ]
        },
        /*计算属性*/
        computed: {
            totalPrice1: function () {
                let ans = 0;
                for (let i=0;i<this.books.length;i++) {
                    ans += this.books[i].price;
                }
                return ans;
            },
            totalPrice2: function () {
                let ans = 0;
                for (let book of this.books) {
                    ans += book.price;
                }
                return ans;
            },
        },
    })
</script>
```

![image-20220301154513741](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301154513741.png)

### 6.3 计算属性的 setter 和 getter



![image-20220301162227779](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301162227779.png)



### 6.4 计算属性和methods的区别

> - 计算属性会判断数据的值是否发生变化，如果没有发生变化，则不会重新执行，使用缓存的数据；
> - `methods` 调用几次执行几次，不会去判断数据的值是否发生了改变。

- 使用 `methods`

  - ```html
    <div id="app">
        <!--方法二：调用methods-->
        <h2>{{getFullName()}}</h2>
        <h2>{{getFullName()}}</h2>
        <h2>{{getFullName()}}</h2>
        <h2>{{getFullName()}}</h2>
    </div>
    
    <script src="../js/vue.js"></script>
    <script>
        let app = new Vue({
            el: "#app",
            data: {
                firstName: '刘',
                lastName: '撷思',
            },
            methods: {
                getFullName: function () {
                    console.log('getFullName');
                    return this.firstName + ' ' + this.lastName;
                }
            }
        })
    </script>
    ```

  - ![image-20220301163131677](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301163131677.png)

  - > `methods` 调用了 4 次

- 使用计算属性

  - ```html
    <div id="app">
    <!--    方法三：计算属性-->
        <h2>{{fullName}}</h2>
        <h2>{{fullName}}</h2>
        <h2>{{fullName}}</h2>
        <h2>{{fullName}}</h2>
    </div>
    
    <script src="../js/vue.js"></script>
    <script>
        let app = new Vue({
            el: "#app",
            data: {
                firstName: '刘',
                lastName: '撷思',
            },
            /*计算属性*/
            computed: {
                fullName: function () {
                    console.log('fullName');
                    return this.firstName + ' ' + this.lastName;
                }
            },
        })
    </script>
    ```

  - ![image-20220301163324978](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301163324978.png)

  - > 只有一次

## 7. v-on

### 7.1 v-on的基本使用和语法糖

> 在前端开发中，需要经常和用户交互。在这个时候，就需要监听用户发出的指令，如点击、拖拽、键盘时间等。
>
> 在 `Vue` 中监听事件使用 `v-on` 指令。

**`v-on` 介绍：**

- **作用：**绑定事件监听器
- **缩写：** `@`

![image-20220301200322508](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301200322508.png)

### 7.2 v-on的参数传递

```html
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            counter: 0,
        },
        methods: {
            btn1Click() {
                console.log("btn1Click");
            }
        }
    })
</script>
```

- 如果该方法不需要额外参数，那么方法后的 `()` 可以不添加。

  - ```html
        <!--事件调用的方法没有参数-->
        <button @click="btn1Click()">按钮1</button>
        <button @click="btn1Click">按钮1-1</button>
    ```

  - ![image-20220301200839221](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301200839221.png)

- 如果方法本身中有一个参数，那么会默认将原生事件 `event` 参数传递进去

  - ```html
        <!--事件调用的方法需要参数-->
        <button @click="btn2Click(123)">按钮2</button>
        <button @click="btn2Click">按钮2-2</button>
    ```

  - ![image-20220301201303543](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301201303543.png)

- 如果需要同时传入某个参数，同时需要 `event` 时，可以通过 `$event` 传入事件

  - ```html
        <!--事件调用的方法需要event对象，也需要其他参数-->
        <button @click="btn3Click">按钮3</button>
        <button @click="btn3Click()">按钮3-1</button>
        <button @click="btn3Click(123)">按钮3-2</button>
        <button @click="btn3Click(123, $event)">按钮3-4</button>
    ```

  - ![image-20220301202133531](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301202133531.png)

### 7.3 v-on修饰符

- 在某些情况下，我们拿到 `event` 的目的可能是进行一些事件处理。
- `Vue` 提供了修饰符来帮助我们方便的处理一些事件：
  - `.stop` - 调用 `event.stopPropagation()`。
  - `.prevent` - 调用 `event.preventDefault()`。
  - `.{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。
  - `.native` - 监听组件根元素的原生事件。
  - `.once` - 只触发一次回调。

![image-20220301202955018](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301202955018.png)

## 8. v-if 条件判断

### 8.1 v-if和v-else-if和v-else的使用

![image-20220301210056659](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301210056659.png)

### 8.2 登录切换的小案例

> 切换账户登录跟邮箱登录

```html
<div id="app">
    <span v-if="type=='username'">
        <label>用户账号：</label>
        <input placeholder="用户账号">
    </span>
    <span v-else>
        <label>邮箱地址：</label>
        <input placeholder="邮箱地址">
    </span>
    <button @click="handle">切换类型</button>
</div>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: "你好呀",
            score: 98,
            type: 'username',
        },
        methods: {
            handle() {
                this.type = this.type == 'username' ? 'email' : 'username';
            }
        }
    })
</script>
```

![image-20220301212254794](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301212254794.png)

**问题描述：**

- 如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。
- 但是按道理讲，我们应该切换到另外一个 `input` 元素中了。
- 在另一个 `input` 元素中，我们并没有输入内容。
- 为什么会出现这个问题呢？

**问题解答：**

- 这是因为 `Vue` 在进行 `DOM` 渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。
- 在上面的案例中，`Vue` 内部会发现原来的 `input` 元素不再使用，直接作为 `else` 中的 `input` 来使用了。

**解决方案**：

- 如果我们不希望 `Vue` 出现类似重复利用的问题，可以给对应的 `input` 添加 `key`
- 并且我们需要保证 `key` 的不同

```html
<div id="app">
    <span v-if="type=='username'">
        <label>用户账号：</label>
        <input placeholder="用户账号" key="username-key">
    </span>
    <span v-else>
        <label>邮箱地址：</label>
        <input placeholder="邮箱地址" key="email-key">
    </span>
    <button @click="handle">切换类型</button>
</div>
```



### 8.3 v-show

#### 8.3.1 v-show的使用

`v-show` 的用法和 `v-if` 非常相似，也用于决定一个元素是否渲染：

#### 8.3.2 v-show与v-if的对比

- `v-if` 和 `v-show` 都可以决定一个元素是否渲染，那么开发中我们如何选择呢？
- `v-if` 当条件为 `false` 时，压根不会有对应的元素在 `DOM` 中。
- `v-show` 当条件为 `false` 时，仅仅是将元素的 `display` 属性设置为 `none` 而已。

```html
<div id="app">
    <h2 v-if="isShow" id="1">{{message}}</h2>
    <h2 v-show="isShow" id="2">{{message}}</h2>
    <h2 v-if="!isShow" id="3">{{message}}, !isShow</h2>
    <h2 v-show="!isShow" id="4">{{message}}, !isShow</h2>
</div>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: "你好呀",
            isShow: true,
        },
    })
</script>
```

![image-20220302110204417](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302110204417.png)

**开发中如何选择呢？**

- 当需要在显示与隐藏之间切片很频繁时，使用 `v-show`
- 当只有一次切换时，通过使用 `v-if`

## 9. v-for 循环

### 9.1 v-for遍历数组

![image-20220302151437869](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302151437869.png)

### 9.2 v-for遍历对象

![image-20220302152124014](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302152124014.png)

### 9.3 v-for绑定和非绑定key

![image-20220302152450275](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302152450275.png)

> 所以一句话，**key的作用主要是为了高效的更新虚拟DOM。**

![数组渲染之后-在中间插入元素的渲染过程](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/%E6%95%B0%E7%BB%84%E6%B8%B2%E6%9F%93%E4%B9%8B%E5%90%8E-%E5%9C%A8%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png)

### 9.4 数组中的哪些方式是响应式的

- 因为 `Vue` 是响应式的，所以当数据发生变化时，`Vue` 会自动检测数据变化，视图会发生对应的更新。
- `Vue` 中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新
  - `push()`：从数组尾部添加元素
  - `pop()`：删除数组最后一个元素
  - `shift()`： 删除数组的第一个元素
  - `unshift()`： 从数组头部添加元素
  - `splice()`：用于添加或删除数组中的元素。
    - `splice(index,howmany,item1,.....,itemX)`
  - `sort()`
  - `reverse()`

> 示例代码

```html
<div id="app">
    <ul>
        <li v-for="item in letters" :key="item">{{item}}</li>
        <button @click="btnClick">按钮</button>
    </ul>
</div>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            letters: ['a', 'b', 'c', 'd'],
            counter: 0,
        },
        methods: {
            btnClick() {
            }
        }
    })
</script>
```

- `push()`

  - ```html
            methods: {
                btnClick() {
                    /*1 push方法*/
                    this.letters.push(this.counter++);
                }
            }
    ```

  - ![image-20220302154450402](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302154450402.png)




## 10. 购物车案例

### 10.1 搭建页面

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<div id="app">
    <div v-if="books.length">
        <table>
            <thead>
            <tr>
                <th></th>
                <th>书籍名称</th>
                <th>出版日期</th>
                <th>价格</th>
                <th>购买数量</th>
                <th>操作</th>
            </tr>
            </thead>
            <tbody>
            <tr v-for="(book, index) in books">
                <!--<td v-for="value in book">{{value}}</td>-->
                <td>{{book.id}}</td>
                <td>{{book.name}}</td>
                <td>{{book.date}}</td>
                <td>￥{{book.price | showPrice}}</td>
                <td>
                    <button @click="decrement(index)" v-bind:disabled="book.count <= 1">-</button>
                    {{book.count}}
                    <button @click="increment(index)">+</button>
                </td>
                <td>
                    <button @click="removeClick(index)">移除</button>
                </td>
            </tr>
            </tbody>
        </table>
        <h2>总价格：￥{{totalPrice}}</h2>
    </div>
    <div v-else>
        购物车为空
    </div>
</div>

<script src="../js/vue.js"></script>
<script src="main.js"></script>
</body>
</html>
```

`style.css`

```css
table {
    border: 1px solid #e9e9e9;
    border-collapse: collapse;
    border-spacing: 0;
}

th, td {
    padding: 8px 16px;
    border: 1px solid #e9e9e9;
    text-align: left;
}

th {
    background-color: #f7f7f7;
    color: #5c6b77;
    font-weight: 600;
}
```

### 10.2 过滤器

```js
const vue = new Vue({
    el: '#app',
    data: {
        books: [
            {
                id: 1,
                name: '《算法导论》',
                date: '2006-9',
                price: 85.00,
                count: 1
            },
            {
                id: 2,
                name: '《UNIX编程艺术》',
                date: '2006-2',
                price: 59.00,
                count: 1
            },
            {
                id: 3,
                name: '《编程珠玑》',
                date: '2008-10',
                price: 39.00,
                count: 1
            },
            {
                id: 4,
                name: '《代码大全》',
                date: '2006-3',
                price: 128.00,
                count: 1
            },
        ],
    },
    /*过滤器*/
    filters: {
        showPrice(price) {
            return price.toFixed(2);
        }
    }
})
```

### 10.3 改变商品数量+移除功能

```js
const vue = new Vue({
    el: '#app',
    data: {
        ......
    }
    methods: {
        increment(index) {
            this.books[index].count++;
        },
        decrement(index) {
            this.books[index].count--;
        },
        removeClick(index) {
            this.books.splice(index, 1);
        },
    },
    /*过滤器*/
    filters: {
        showPrice(price) {
            return price.toFixed(2);
        }
    }
})
```

### 10.4 计算总价格

```js
const vue = new Vue({
    el: '#app',
    data: {
        books: [
            ......
            ]
    },
    computed: {
        totalPrice() {
            let ans = 0;
            for (let i=0;i<this.books.length;i++) {
                ans += this.books[i].price * this.books[i].count;
            }
            return ans.toFixed(2);
        }
    },
    methods: {
        ......
    },
    /*过滤器*/
    filters: {
        ......
    }
})
```

## 11. v-model 表单绑定

### 11.1 JavaScript高阶函数的使用

1. `filter`函数

   - ```js
     const nums = [10, 20, 111, 222, 444, 40, 50]
     /*filter中的回调函数必须返回boolean值
     * 返回true时 函数内部会自动将这次回调的n加入到新的数组中
     * 返回false时， 函数内部会过滤掉n*/
     let newNums = nums.filter(function (n) {
         return n <= 100;
     })
     console.log(newNums);
     
     /*[10,20,40,50]*/
     ```

2. `map` 函数

   - ```js
     const newNums = [10,20,40,50]
     let newNums2 = newNums.map(function (n) {
         return n * 2;
     })
     /*[20,40,80,100]*/
     ```

3. `reduce`函数

   - ```js
     /*3. reduce  对数组中所有内容进行汇总*/
     newNums2.reduce(function (preValue, n) {
         return preValue + n;
     }, 0)
     // 第一次 preValue: 0  n: 20
     // 第二次 preValue: return的返回值 n: 40
     ```

### 11.2 v-model的使用与原理

- 表单控件在实际开发中是非常常见的。特别是对于用户信息的提交，需要大量的表单。
- `Vue` 中使用 `v-model` 指令来实现表单元素和数据的双向绑定。
- **案例场景**
  - 当我们在输入框输入内容时
  - 因为 `input` 中的 `v-model` 绑定了 `message` ，所以会实时将输入的内容传递给 `message`，`message`发生改变。
  - 当 `message` 发生改变时，因为上面我们使用 `Mustache` 语法，将 `message` 的值插入到 `DOM` 中，所以`DOM` 会发生响应的改变。
  - 所以，通过 `v-model` 实现了双向的绑定。

![image-20220302204643052](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302204643052.png)

### 11.3 v-model原理

- `v-model` 其实是一个语法糖，它的背后本质上是包含两个操作：
  1. `v-bind` 绑定一个 `value` 属性
  2. `v-on` 指令给当前元素绑定 `input` 事件

![image-20220302205322339](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302205322339.png)

> 进阶：

```html
<div id="app">
    <input type="text" v-bind:value="message" v-on:input="message = $event.target.value">
    {{message}}
</div>
```

![image-20220302205503570](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302205503570.png)

### 11.4 v-model结合radio类型

- ```html
  <div id="app">
      <label for="gentle">
          <input type="radio" id="gentle" name="gender" value="男" v-model="gender">男
      </label>
      <label for="lady">
          <input type="radio" id="lady" name="gender" value="女" v-model="gender">女
      </label>
      <h2>您选择的性别是: {{gender}}</h2>
  </div>
  <script src="../js/vue.js"></script>
  <script>
      const vue = new Vue({
          el: '#app',
          data: {
              message: '你好啊',
              gender: '',
          },
      })
  </script>
  ```

- ![image-20220302211502117](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302211502117.png)

### 11.5 v-model结合checkbox

- 单选框

  - ```html
        <!--单选框-->
        <label for="agree">
            <input type="checkbox" id="agree" v-model="isAgree">同意协议
        </label>
        <h2>您选择的是: {{isAgree}}</h2>
        <button :disabled="!isAgree">下一步</button>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const vue = new Vue({
            el: '#app',
            data: {
                message: '你好啊',
                isAgree: false,
            },
        })
    </script>
    ```

  - ![image-20220302212138122](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302212138122.png)![image-20220302212148797](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302212148797.png)

- 复选框

  - ```html
    <div>  
    <!--多选框-->
        <input type="checkbox" value="篮球" v-model="hobbies">篮球
        <input type="checkbox" value="足球" v-model="hobbies">足球
        <input type="checkbox" value="羽毛球" v-model="hobbies">羽毛球
        <input type="checkbox" value="乒乓球" v-model="hobbies">乒乓球
        <h2>您选择是：{{hobbies}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const vue = new Vue({
            el: '#app',
            data: {
                message: '你好啊',
                isAgree: false,
                hobbies: [],
            },
        })
    </script>
    ```

  - ![image-20220302212509233](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302212509233.png)

### 11.6 v-model结合selcet

- 选择一个

  - ```html
    <div id="app">
        <!--1. 选择一个-->
        <select name="abc" v-model="fruit">
            <option value="苹果">苹果</option>
            <option value="香蕉">香蕉</option>
            <option value="草莓">草莓</option>
            <option value="菠萝">菠萝</option>
            <option value="榴莲">榴莲</option>
        </select>
        <h2>您选择的水果是: {{fruit}}</h2>
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const vue = new Vue({
            el: '#app',
            data: {
                message: '你好啊',
                fruit: '',
            },
        })
    </script>
    ```

  - ![image-20220302213403629](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302213403629.png)

- 多选

  - ```html
    <div> 
    <select name="abc" v-model="fruits" multiple>
            <option value="苹果">苹果</option>
            <option value="香蕉">香蕉</option>
            <option value="草莓">草莓</option>
            <option value="菠萝">菠萝</option>
            <option value="榴莲">榴莲</option>
        </select>
        <h2>您选择的水果是: {{fruits}}</h2>
        <!--1. 选择多个-->
    </div>
    <script src="../js/vue.js"></script>
    <script>
        const vue = new Vue({
            el: '#app',
            data: {
                message: '你好啊',
                fruit: '',
                fruits: [],
            },
        })
    </script>
    ```

  - ![image-20220302213545069](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220302213545069.png)

### 11.7 v-model值绑定

> 动态的给 `value` 赋值而已

- 我们前面的 `value` 中的值，可以回头去看一下，都是在定义 `input` 的时候直接给定的。
- 但是真实开发中，这些 `input` 的值可能是从网络获取或定义在 `data` 中的。
- 所以我们可以通过 `v-bind:value` 动态的给 `value` 绑定值。

```html
<div id="app">
    <label v-for="item in originHobbies">
        <input type="checkbox" :value="item" v-model="fruits">{{item}}
    </label>
    <h2>您选择的是: {{fruits}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
            fruit: '',
            fruits: [],
            originHobbies: ['篮球', '足球', '乒乓球', '羽毛球', '台球', '悠悠球']
        },
    })
</script>
```

![image-20220303102535908](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303102535908.png)

### 11.8 v-model修饰符的私用

1. `lazy` 修饰符：

   - 默认情况下，`v-model` 默认是在 `input` 事件中同步输入框的数据的。

   - 也就是说，一旦有数据发生改变对应的 `data` 中的数据就会自动发生改变。

   - `lazy` 修饰符可以让数据在失去焦点或者回车时才会更新：

   - ```html
     <div id="app">
         <!--1. lazy-->
         <input type="text" v-model.lazy="message">
         <h2>{{message}}</h2>
     </div>
     <script src="../js/vue.js"></script>
     <script>
         const vue = new Vue({
             el: '#app',
             data: {
                 message: '你好啊',
             },
         
         })
     </script>
     ```

2. `number` 修饰符：

   - 默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。

   - 但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。

   - `number` 修饰符可以让在输入框中输入的内容自动转成数字类型：

   - ```html
     <div id="app">
         <!--2. number-->
         <input type="number" v-model.number="age">
         <h2>{{age}} ---- {{typeof age}}</h2>
     </div>
     <script src="../js/vue.js"></script>
     <script>
         const vue = new Vue({
             el: '#app',
             data: {
                 message: '你好啊',
                 age: 0,
             },
         })
     </script>
     ```

3. `trim` 修饰符：

   - 如果输入的内容首尾有很多空格，通常我们希望将其去除

   - `trim` 修饰符可以过滤内容左右两边的空格

   - ```html
     <div id="app">
         <!--3. 修饰符 trim-->
         <input type="text" v-model.trim="name">
         <h2>您输入的name是：{{name}}</h2>
     </div>
     <script src="../js/vue.js"></script>
     <script>
         const vue = new Vue({
             el: '#app',
             data: {
                 message: '你好啊',
                 age: 0,
                 name: '',
             },
         })
     </script>
     ```

## 12. 组件化开发

### 12.1 认识组件化

#### 12.1.1 什么是组件化

- 如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。
- 但如果，我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。

![image-20220303110223959](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303110223959.png)

#### 12.1.2 Vue.js组件思想

组件化是 `Vue.js` 中的重要思想

- 它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。
- 任何的应用都会被抽象成一颗组件树。

![image-20220303110421075](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303110421075.png)

组件化思想的应用：

- 有了组件化的思想，我们在之后的开发中就要充分的利用它。
- 尽可能的将页面拆分成一个个小的、可复用的组件。
- 这样让我们的代码更加方便组织和管理，并且扩展性也更强。

### 12.2 注册组件

#### 12.2.1 注册组件的基本步骤

组件的使用分成三个步骤：

- 创建组件构造器
- 注册组件
- 使用组件。

![image-20220303111028675](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303111028675.png)

<img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303131318639.png" style="zoom:50%"><img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303131710061.png" style="zoom:70%">

#### 12.2.2 注册组件步骤解析

1. `Vue.extend()`：
   - 调用 `Vue.extend()` 创建的是一个组件构造器。 
   - 通常在创建组件构造器时，传入 `template` 代表我们自定义组件的模板。
   - 该模板就是在使用到组件的地方，要显示的 `HTML` 代码。
   - 事实上，这种写法在 `Vue2.x` 的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础。
2. `Vue.component()`：
   - 调用 `Vue.component()` 是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。
   - 所以需要传递两个参数：1、注册组件的标签名 2、组件构造器。
3. 组件必须挂载在某个 `Vue` 实例下

![image-20220303132133289](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303132133289.png)

### 12.3 其他组件补充

#### 12.3.1 全局组件和局部组件

- 当我们通过**调用 `Vue.component()` 注册组件时，组件的注册是全局的**
  - **这意味着该组件可以在任意 `Vue` 示例下使用。**
- 如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件

![image-20220303143412912](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303143412912.png)

#### 12.3.2 父组件和子组件的区分

```html
<div id="app">
<!--    <cpn1></cpn1>-->
    <cpn2></cpn2>
    <p>------</p>
    <cpn1></cpn1>
</div>
<script src="../js/vue.js"></script>

<script>
    <!--1. 第一个组件 子组件-->
    const cpnC1 = Vue.extend({
        template: `
        <div>
            <h2>我是标题1</h2>
            <p>我是内容 哈哈哈哈</p>
        </div>
        `
    })

    /*2. 第二个组件 父组件*/
    const cpnC2 = Vue.extend({
        template: `
        <div>
            <h2>我是标题2</h2>
            <p>我是内容 嘿嘿嘿嘿</p>
            <cpn1></cpn1>
        </div>
        `,
        components: {
            cpn1: cpnC1
        }
    })

    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
        },
        components: {
            // cpn1: cpnC1,
            cpn2: cpnC2,
        }
    })
</script>
```

![image-20220303145923255](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303145923255.png)

![image-20220303145930164](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303145930164.png)

#### 12.3.3 注册组件的语法糖写法

- 全局组件的语法糖

  - ```html
    <script>
            /*1 创建组件构造器对象*/
        const cpnC = Vue.extend({
            template:
                `<div>
                    <h2>我是标题</h2>
                    <p>我是内容，哈哈哈哈</p>
                    <p>我是内容，呵呵呵呵</p>
                </div>`
        })
        /*2. 注册组件*/
        Vue.component('my-cpn', cpnC)
    
        /*上面两步等价于下面*/
        Vue.component('mu-cpn', {
            template:
                `<div>
                    <h2>我是标题</h2>
                    <p>我是内容，哈哈哈哈</p>
                    <p>我是内容，呵呵呵呵</p>
                </div>`
        })
    </script>
    ```

- 局部组件的语法糖

  - ```html
    <script>    
    /*注册局部组件的语法糖*/
        const vue = new Vue({
            el: '#app',
            data: {
                message: '你好啊',
            },
            component: {
                'cpn2': {
                    template:
                        `<div>
                    <h2>我是标题</h2>
                    <p>我是内容，哈哈哈哈</p>
                    <p>我是内容，呵呵呵呵</p>
                </div>`
            }
        })
    </script>
    ```

#### 12.3.4 组件模板分离

- 方式一：

  - ```html
    <!--1 方式一：script标签 类型必须为text/x-template-->
    <script type="text/x-template" id="cpn">
        <div>
            <h2>我是标题</h2>
            <p>我是内容</p>
        </div>
    </script>
    <script>
        /*1 注册全局组件*/
        Vue.component('my-cpn', {
            template: `#cpn`
        })
    </script>
    ```

- 方式二：

  - ```html
    
    <!--方式二：template-->
    <template id="cpn">
        <div>
            <h2>我是标题2</h2>
            <p>我是内容2</p>
        </div>
    </template>
    
    <script src="../js/vue.js"></script>
    <script>
        /*1 注册全局组件*/
        Vue.component('my-cpn', {
            template: `#cpn`
        })
    </script>
    ```

```html
<div id="app">
    <my-cpn></my-cpn>
    <my-cpn></my-cpn>
    <my-cpn></my-cpn>
    <my-cpn></my-cpn>
</div>

<!--1 方式一：script标签 类型必须为text/x-template-->
<script type="text/x-template" id="cpn">
    <div>
        <h2>我是标题</h2>
        <p>我是内容</p>
    </div>
</script>

<!--方式二：template-->
<template id="cpn">
    <div>
        <h2>我是标题2</h2>
        <p>我是内容2</p>
    </div>
</template>

<script src="../js/vue.js"></script>
<script>
    /*1 注册全局组件*/
    Vue.component('my-cpn', {
        template: `#cpn`
    })

    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
        }
    })
</script>
```

### 12.4 组件不能访问Vue实例数据

- 组件是一个单独功能模块的封装：
  - 这个模块有属于自己的 `HTML` 模板，也应该有属性自己的数据 `data` 。

> 组件是不能直接访问 `Vue` 实例中的数据的

#### 12.4.1 组件的 `data` 属性

`Vue` 组件应该有自己保存数据的地方

- 组件对象也有一个 `data` 属性(也可以有 `methods`等属性，下面我们有用到)
- 只是这个 `data` 属性必须是一个函数
- 而且这个函数返回一个对象，对象内部保存着数据

![image-20220303200643430](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303200643430.png)

12.4.2 组件不能访问Vue示例数据的原因

> 在于 `Vue` 让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响

![image-20220303210424280](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303210424280.png)

## 13. 父子组件通信

子组件是不能引用父组件或者Vue实例的数据的。

但是，在开发中，往往一些数据确实需要从上层传递到下层：

- 比如在一个页面中，我们从服务器请求到了很多的数据。
- 其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。
- 这个时候，并不会让子组件再次发送一个网络请求，而是直接让**大组件(父组件)**将数据传递给**小组件(子组件)**。

>  如何进行父子组件间的通信呢

- 通过 `props` 向子组件传递数据
- 通过事件向父组件发送消息

![image-20220303211430472](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303211430472.png)

### 13.1 父传子 props

#### 13.1.1 使用方法

在组件中，使用选项 `props` 来声明需要从父级接收到的数据。

`props` 的值有两种方式：

- 方式一：字符串数组，数组中的字符串就是传递时的名称。
- 方式二：对象，对象可以设置传递时的类型，也可以设置默认值等。**推荐**

> 方式一：

```html
<div id="app">
    <cpn :cmovies="movies" :cmessage="message"></cpn>
</div>
<template id="cpn">
    <div>
        <lu>
            <li v-for="item in cmovies">{{item}}</li>
        </lu>
        <h2>{{cmessage}}</h2>
    </div>
</template>
<script src="../js/vue.js"></script>
<script>

    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
            movies: ['进击的巨人', '海贼王', '火影忍者', '鬼灭之刃'],
        },
        components: {
            'cpn': {
                template: '#cpn',
                props: ['cmovies', 'cmessage'],
            }
        }
    })
</script>
```

![image-20220303213816650](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220303213816650.png)

> 传对象

```html
<div id="app">
    <cpn :cmovies="movies" :cmessage="message"></cpn>
</div>
<template id="cpn">
    <div>
        <lu>
            <li v-for="item in cmovies">{{item}}</li>
        </lu>
        <h2>{{cmessage}}</h2>
    </div>
</template>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
            movies: ['进击的巨人', '海贼王', '火影忍者', '鬼灭之刃'],
        },
        components: {
            'cpn': {
                template: '#cpn',
                // props: ['cmovies', 'cmessage'],
                props: {
                    cmessage: {
                        type: String,   /*类型限制*/
                        default: '',  /*默认值*/
                        required: true, /*true表示使用cmessage这个属性的时候必须要传值*/
                    },
                    cmovies: {
                        type: Array,
                        /*类型是数组或者对象的时候，默认值必须要是一个函数*/
                        default() {
                            return [];
                        }
                    }
                }
            }
        }
    })
</script>
```

支持的数据类型：

- `String`
- `Number`
- `Boolean`
- `Array`
- `Object`
- `Date`
- `Function`
- `Symbol`

![image-20220304104137256](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304104137256.png)

#### 13.1.2 props驼峰标识

> 不支持驼峰标识

```html
<div id="app">
    <cpn :cInfo="info"></cpn>
</div>

<template id = "cpn">
    <h2>{{cInfo}}</h2>
</template>

<script src="../js/vue.js"></script>
<script>

    const cpn = {
        template: '#cpn',
        props: {
            cInfo: {
                type: Object,
                default() {
                    return {};
                }
            }
        }
    }

    const vue = new Vue({
        el: '#app',
        data: {
            info: {
                name: '刘云杰',
                age: 18,
                height: 188,
            }
        },
        components: {
            cpn
        }
    })
</script>
```

![image-20220304105102914](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304105102914.png)

> 解决方法
>
> ​	`cInfo` 改为 `c-info`

```html

```

![image-20220304105251852](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304105251852.png)

![image-20220304105311525](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304105311525.png)

![image-20220304110941068](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304110941068.png)

### 13.2 子传父

- `props` 用于父组件向子组件传递数据，还有一种比较常见的是子组件传递数据或事件到父组件中。
- 我们应该如何处理呢？这个时候，我们需要使用**自定义事件**来完成。
- 什么时候需要自定义事件呢？
  - 当子组件需要向父组件传递数据时，就要用到自定义事件了。
  - 我们之前学习的 `v-on` 不仅仅可以用于监听 DOM 事件，也可以用于组件间的自定义事件。
- 自定义事件的流程：
  - 在子组件中，通过 `$emit()` 来触发事件。
  - 在父组件中，通过 `v-on` 来监听子组件事件。

```html
<!--父组件模板-->
<div id="app">
    <!--这里不支持驼峰标识-->
    <vpn @item-click="apcClick"></vpn>
</div>
<!--子组件模板-->
<template id="cpn">
    <div>
        <button v-for="item in categories"
                @click="btnClick(item)">
            {{item.name}}
        </button>
    </div>
</template>

<script src="../js/vue.js"></script>
<script>
    /*1. 子组件*/
    const vpn = {
        template: '#cpn',
        data() {
            return {
                categories: [
                    {id: 'aaa', name: '热门推荐'},
                    {id: 'bbb', name: '手机数码'},
                    {id: 'ccc', name: '家用家电'},
                    {id: 'ddd', name: '电脑办公'},
                ]
            }
        },
        methods: {
            btnClick(item) {
                /*向父组件通信  自定义事件
                * item-click是事件的名称
                * item是事件要传递的参数
                */
                this.$emit('item-click', item)
            }
        }
    }

    /*2. 父组件*/
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
        },
        components: {
            vpn
        },
        methods: {
            apcClick(item) {
                console.log(item);
            }
        }
    })
</script>
```

### 13.3 父子间通信案例1

> - 父组件通过 `props` 将 `counter` 传递给子组件；
> - 子组件通过自定义事件 `add-counter` 和 `decrement-counter` 将点击事件传递给父组件。

```html
<!--父组件模板-->
<div id="app">
    <!--这里不支持驼峰标识-->
    <vpn @add-counter="addCounter" @decrement-counter="decrementCounter" :child-counter="counter"></vpn>
</div>
<!--子组件模板-->
<template id="cpn">
    <div>
        <h2>{{childCounter}}</h2>
        <button @click="increment()">+</button>
        <button @click="decrement()">-</button>
    </div>
</template>

<script src="../js/vue.js"></script>
<script>
    /*1. 子组件*/
    const vpn = {
        template: '#cpn',
        props: {
            childCounter: {
                required: true,
            }
        },
        methods: {
            increment() {
                this.$emit('add-counter');
            },
            decrement() {
                this.$emit('decrement-counter')
            }
        }
    }

    /*2. 父组件*/
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
            counter: 0,
        },
        components: {
            vpn
        },
        methods: {
            addCounter() {
                this.counter++;
            },
            decrementCounter() {
                this.counter--;
            }
        }
    })
</script>
```

![image-20220304125142083](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304125142083.png)

### 13.4 父子间通信案例2

> 注意：
>
> - 子组件中 `number1` 和 `number2` 的值初始来源于 `num1` 和 `num2`，将  `number1` 和 `number2`与 `<input>` 双向绑定的时候不能直接绑定  `number1` 和 `number2`，需要找一个中间值。

```html
<div id="app">
    <cpn :number1="num1"
         :number2="num2"
         @num1change="num1change"
         @num2change="num2change"/>
</div>
<template id="cpn">
    <div>
        <h2>props: {{number1}}</h2>
        <h2>data: {{dnumber1}}</h2>
        <input type="text" :value="dnumber1" @input="num1Input">
        <h2>props: {{number2}}</h2>
        <h2>data: {{dnumber2}}</h2>
        <input type="text" :value="dnumber2" @input="num2Input">
    </div>
</template>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            num1: 1,
            num2: 0,
        },
        methods: {
            num1change(value) {
                this.num1 = parseFloat(value);
            },
            num2change(value) {
                this.num2 =  parseFloat(value);
            },
        },
        components: {
            cpn: {
                template: '#cpn',
                props: {
                    number1: Number,
                    number2: Number,
                },
                data() {
                    return {
                        dnumber1: this.number1,
                        dnumber2: this.number2,
                    }
                },
                methods: {
                    num1Input(event) {
                        this.dnumber1 = event.target.value;
                        this.$emit("num1change", this.dnumber1);

                        this.dnumber2 = this.dnumber1 * 100;
                        this.$emit("num2change", this.dnumber2);
                    },
                    num2Input(event) {
                        this.dnumber2 = event.target.value;
                        this.$emit("num2change", this.dnumber2);

                        this.dnumber1 = this.dnumber2 / 100;
                        this.$emit("num1change", this.dnumber1);
                    },
                }
            },
        }
    })
</script>
```

![image-20220304151244724](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304151244724.png)

<img src="https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304155433367.png"/>

### 13.5 父子组件的访问方式 

有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问根组件。

- 父组件访问子组件：使用  `$children` 或 `$refs`
- 子组件访问父组件：使用 `$parent`



#### 13.5.1 `children` 方式（不推荐）

- ```html
  <div id="app">
      <cpn></cpn>
      <button @click="btnClick">按钮</button>
  </div>
  <template id="cpn">
      <div>我是子组件</div>
  </template>
  <script src="../js/vue.js"></script>
  <script>
      const vue = new Vue({
          el: '#app',
          data: {
              message: '你好啊',
          },
          methods: {
              btnClick() {
                  console.log(this.$children);
                  this.$children[0].showMessage();
              }
          },
          components: {
              cpn: {
                template: '#cpn',
                methods: {
                    showMessage() {
                        console.log('showMessage');
                    }
                }
              },
          }
      })
  </script>
  ```

- ![image-20220304161011762](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304161011762.png)

#### 13.5.2 `refs`方式

![image-20220304161619050](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304161619050.png)

![image-20220304161551590](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304161551590.png)

## 14. 插槽slot

组件的插槽

- 组件的插槽也是为了让我们封装的组件更加具有扩展性。
- 让使用者可以决定组件内部的一些内容到底展示什么

### 14.1 插槽的基本使用

> 1. 插槽的基本使用 `<slot></slot>`
> 2. 插槽的默认值 `<slot>xxxxx</slot>`
> 3. 如果有多个值，同时放入到组件中进行替换时，一起作为替换元素

```html
<div id="app">
    <cpn><button>按钮</button></cpn>
    <cpn><span>哈哈</span></cpn>
    <cpn><i>呵呵</i></cpn>
    <cpn><button>按钮2</button></cpn>
    <cpn>
        <i>hahahaha</i>
        <b>yiyiyiyi</b>
        <div>divdiv</div>
        <p>ppppppppp</p>
    </cpn>
    <cpn></cpn>
    <cpn></cpn>
    <cpn></cpn>
    <cpn></cpn>
</div>
<template id="cpn">
    <div>
        <h2>我是插槽</h2>
        <p>我是组件</p>
        <slot><button>button</button></slot>
    </div>
</template>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
        },
        components: {
            cpn: {
                template: '#cpn',
            }
        }
    })
</script>
```

![image-20220304184105122](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304184105122.png)

### 14.2 具名插槽

> 给 `slot` 元素一个 `name` 属性即可
>
> `<slot name='myslot'></slot>`

```html
<div id="app">
    <cpn>
        <span slot="center">标题</span>
    </cpn>
    <cpn>
        <button slot="left">按钮</button>
    </cpn>
</div>
<template id="cpn">
    <div>
        <slot name="left"><span>左边</span></slot>
        <slot name="center"><span>中间</span></slot>
        <slot name="right"><span>右边</span></slot>
        <slot><span>哈哈哈</span></slot>
    </div>
</template>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
        },
        components: {
            cpn: {
                template: '#cpn',
            }
        }
    })
</script>
```

![image-20220304191712589](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304191712589.png)

### 14.3 编译作用域

> **父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。**

```html
<div id="app">
    <cpn v-slot="isShow"></cpn>
</div>
<template id="cpn">
    <div>
        <h2>我是子组件</h2>
        <p>我是内容 哈哈哈</p>
        <button v-show="isShow">按钮</button>
    </div>
</template>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
            isShow: true,
        },
        components: {
            cpn: {
                template: '#cpn',
                data() {
                    return {
                        isShow: false,
                    }
                }
            }
        },
    })
</script>
```

![image-20220304192551618](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304192551618.png)

### 14.4 作用域插槽的使用

> 目的：父组件替换插槽的标签，但是内容由子组件来提供。

我们先提一个需求：

- 子组件中包括一组数据，比如：`Languages: ['JavaScript', 'Python', 'Swift', 'Go', 'C++']`
- 需要在多个界面进行展示：
  - 某些界面是以水平方向一一展示的，
  - 某些界面是以列表形式展示的，
  - 某些界面直接展示一个数组
- 内容在子组件，希望父组件告诉我们如何展示，怎么办呢？
  - 利用 `slot` 作用域插槽就可以了

```html
<div id="app">
    <cpn></cpn>
    <cpn>
        <!--目的是获取子组件中的pLanguages-->
        <template slot-scope="slot">
            <span v-for="item in slot.data">{{item}}-</span>
        </template>
    </cpn>
    <cpn>
        <!--目的是获取子组件中的pLanguages-->
        <template slot-scope="slot">
            <span>{{slot.data}}</span>
        </template>
    </cpn>
</div>
<template id="cpn">
    <div>
        <slot :data="pLanguages">
            <ul>
                <li v-for="item in pLanguages">{{item}}</li>
            </ul>
        </slot>
    </div>
</template>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: '你好啊',
        },
        components: {
            cpn: {
                template: '#cpn',
                data() {
                    return {
                        pLanguages: ['JavaScript', 'Python', 'Swift', 'Go', 'C++'],
                    }
                }
            },
        },
    })
</script>
```

![image-20220304194428082](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304194428082.png)

![image-20220304194438906](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220304194438906.png)

## 15. webpack

### 15.1 什么是webpack

webpack是一个现代的JavaScript应用的静态 **模块打包** 工具。

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/32af52ff9594b121517ecdd932644da4.png)

从图中我们可以看出，Webpack 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。

`cnpm install webpack@3.6.0 -g`

`webpack --version`

### 15.2 webpack基本使用

> `webpack 3.6.0` 的打包命令：
>
> `webpack ./src/main.js ./dist/bundle.js`



```js
// 1.使用commonjs的模块化规范
const {add, mul} = require('./mathUtil.js')

console.log(add(20, 30));
console.log(mul(20, 30));

// 2. 使用ES6的模块化规范
import {
    name, age, height
} from "./info";

console.log(name);
console.log(age);
console.log(height)
```

### 15.3 webpack.config.js 和 package.json 配置

如果每次使用 `webpack` 的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读。

1. `npm init`

   - 会创建 `package.json` 文件

2. 新建 `webpack.config.js` 文件

   - ```js
     const path = require('path')
     
     module.exports = {
         entry: './src/main.js',/*入口*/
         output: {
             path: path.resolve(__dirname, 'dist'),/*路径  这里只能填绝对路径*/
             filename: 'bundle.js', /*文件名*/
         },/*出口*/
     }
     ```

3.  进阶：使用 `npm run build` 命令代替 `webpack`

   - 配置 `package.json`

   - ```json
     {
       "name": "meetwebpack",
       "version": "1.0.0",
       "description": "",
       "main": "index.js",
       "scripts": {
         "test": "echo \"Error: no test specified\" && exit 1",
         "build": "webpack" // 添加命令  默认先运行本地的webpack 而非全局webpack
       },
       "author": "",
       "license": "ISC"
     }
     
     ```

### 15.4 webpack中使用css文件的配置

1. `webpack` 主要是用来处理编写的 `js` 代码
   - 但是开发中不仅仅需要处理 `js` 文件，还需要加载 `css`、图片等。这个时候就需要给 `webpack` 扩展对应的 `loader` 即可。
2. `loader` 使用过程
   1. 通过 `npm` 安装需要使用的 `loader`
   2. 在 `webpack.config.js` 中的 `mudule` 关键字下进行配置



#### 15.4.1 `css-loader`

- 新建一个 `css` 文件 `normal.css`

  - ```css
    body {
        background-color: antiquewhite;
    }
    ```

- `main.js` 中引入该 `css`文件

  - ```js
    // 3. 依赖css文件
    require('./css/normal.css')
    ```

- 安装 `css-loader` 和 `style-loader`

  - ```bash
    npm install --save-dev style-loader
    npm install --save-dev css-loader
    ```

- 配置 `webpack.config.js`

  - ```js
    const path = require('path')
    
    module.exports = {
        /*处理Js文件*/
        entry: './src/main.js',/*入口*/
        output: {
            path: path.resolve(__dirname, 'dist'),/*路径  这里只能填绝对路径*/
            filename: 'bundle.js', /*文件名*/
        },/*出口*/
        /*处理CSS文件*/
        module: {
            rules: [
                {
                    test: /\.css$/i,
                    /*css-loader只负责加载css文件
                    style-loader负责将样式添加到DOM中
                    使用多个loader的时候 读取顺序：从右向左
                    * */
                    use: ["style-loader", "css-loader"],
                },
            ],
        },
    }
    ```



> - `css-loader` 只负责加载 `css` 文件
> - `style-loader` 负责将样式添加到 `DOM` 中
> - 使用多个 `loader` 的时候 读取顺序：从右向左

#### 15.4.2 less文件使用

1. 新建 `special.less` 文件

   - ```less
     @fontSize: 50px;
     @fontColor: orange;
     
     body {
       font-size: @fontSize;
       color: @fontColor;
     }
     
     ```

2. `main.js` 中引入该 `less`文件

   - ```js
     // 4. 依赖less文件
     require('./css/special.less')
     ```

3. 安装 `less-loader` 

   - ```bash
     npm install less less-loader --save-dev
     # 注意对应版本号
     ```

4. 配置 `webpack.config.js`

   - ```js
     const path = require('path')
     
     module.exports = {
         /*处理Js文件*/
         entry: './src/main.js',/*入口*/
         output: {
             path: path.resolve(__dirname, 'dist'),/*路径  这里只能填绝对路径*/
             filename: 'bundle.js', /*文件名*/
         },/*出口*/
         /*处理CSS文件*/
         module: {
             rules: [
                 {
                     test: /\.css$/i,
                     /*css-loader只负责加载css文件
                     style-loader负责将样式添加到DOM中
                     使用多个loader的时候 读取顺序：从右向左
                     * */
                     use: ["style-loader", "css-loader"],
                 },
                 {
                     test: /\.less$/i,
                     use: [
                         {
                             loader: 'style-loader',
                         },
                         {
                             loader: 'css-loader',
                         },
                         {
                             loader: 'less-loader',
                         },
                     ],
                 },
             ],
         },
     }
     ```

5. ![image-20220305110113185](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220305110113185.png)



#### 15.4.3 webpack图片文件的处理

1. 添加 图片 文件

2. 修改 `css` 文件

   - ```css
     body {
         background: url("../img/avatar.jpg");
     }
     ```

3. 安装 `file-loader`

   - ```bash
     npm install file-loader --save-dev
     ```

4. 配置 `webpack.config.js`

   - ```js
     const path = require('path')
     
     module.exports = {
         /*处理Js文件*/
         entry: './src/main.js',/*入口*/
         output: {
             path: path.resolve(__dirname, 'dist'),/*路径  这里只能填绝对路径*/
             filename: 'bundle.js', /*文件名*/
             publicPath: 'dist/', /*配置上这个以后涉及到url的操作会自动把这个路径添加进去*/
         },/*出口*/
         /*处理CSS文件*/
         module: {
             rules: [
                 {
                     test: /\.css$/i,
                     /*css-loader只负责加载css文件
                     style-loader负责将样式添加到DOM中
                     使用多个loader的时候 读取顺序：从右向左
                     * */
                     use: ["style-loader", "css-loader"],
                 },
                 {
                     test: /\.less$/i,
                     use: [
                         {
                             loader: 'style-loader',
                         },
                         {
                             loader: 'css-loader',
                         },
                         {
                             loader: 'less-loader',
                         },
                     ],
                 },
                 {
                     test: /\.(png|jpg|gif)$/,
                     use: [
                         {
                             loader: 'file-loader',
     
                             options: {
                                 name: 'img/[name].[hash:8].[ext]' /*文件的路径已经名字*/
                             },
                             // mode: 'development',
                         },
                     ],
                 },
             ],
         },
     }
     ```

   - ![image-20220305122848278](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220305122848278.png)



#### 15.4.4 ES6语法处理

如果希望将ES6的语法转成ES5，那么就需要使用 `babel`

```bash
npm install --save-dev babel-loader@7 babel-core babel-preset-es2015
```

配置 `webpack.config.js`

![image-20220305123202513](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220305123202513.png)

#### 15.4.5 wepack配置vue

- ```bash
   cnpm install vue@2.5.21 --save
   '@2.5.21' 指的是vue的版本号 
  ```

- `main.js`

  - ```js
    // 5. 使用Vue进行开发
    import Vue from 'vue'
    
    const app = new Vue({
        el: '#app',
        data: {
            message: 'Hello webpack',
        }
    })
    ```

- 出现问题

  - ![image-20220305125931313](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220305125931313.png)

- 解决方法

  - `webpack.config.js`

  - ```js
    const path = require('path')
    
    module.exports = {
        /*处理Js文件*/
        entry: './src/main.js',/*入口*/
        output: {
            path: path.resolve(__dirname, 'dist'),/*路径  这里只能填绝对路径*/
            filename: 'bundle.js', /*文件名*/
            publicPath: 'dist/', /*配置上这个以后涉及到url的操作会自动把这个路径添加进去*/
        },/*出口*/
        /*处理CSS文件*/
        module: {
            rules: [
                {
                    test: /\.css$/i,
                    /*css-loader只负责加载css文件
                    style-loader负责将样式添加到DOM中
                    使用多个loader的时候 读取顺序：从右向左
                    * */
                    use: ["style-loader", "css-loader"],
                },
                {
                    test: /\.less$/i,
                    use: [
                        {
                            loader: 'style-loader',
                        },
                        {
                            loader: 'css-loader',
                        },
                        {
                            loader: 'less-loader',
                        },
                    ],
                },
                {
                    test: /\.(png|jpg|gif)$/,
                    use: [
                        {
                            loader: 'file-loader',
    
                            options: {
                                name: 'img/[name].[hash:8].[ext]' /*文件的路径已经名字*/
                            },
                            // mode: 'development',
                        },
                    ],
                },
            ],
        },
        /*指明vue使用runtime-compile版本*/
        resolve: {
            alias: {
                'vue$': 'vue/dist/vue.esm.js',
            }
        }
    }
    ```

#### 15.4.6 el与template的区别

- 在前面的 `Vue` 实例中，我们定义了 `el` 属性，用于和 `index.html` 中的 `#app` 进行绑定，让 `Vue` 实例之后可以管理它其中的内容
- 这里，我们可以将 `div` 元素中的 `{{message}}` 内容删掉，只保留一个基本的 `id` 为 `div` 的元素
- 但是如果我依然希望在其中显示 `{{message}}` 的内容，应该怎么处理呢？
- 我们可以再定义一个 `template`属性，代码如下：

```js
// 5. 使用Vue进行开发
import Vue from 'vue'

const app = new Vue({
    el: '#app',
    template:
        `<div>
          <h2>{{message}}</h2>
        <button @click="btnClick">按钮</button>
        <h2>{{name}}</h2>
        </div>`,
    data: {
        message: 'Hello webpack',
        name: '刘云杰',
        methods : {
            btnClick() {
                console.log('lyj ');
            }
        }
    }
})
```

#### 15.4.7 vue的终极使用方式

- 优化第一步：

  - ```js
    // 5. 使用Vue进行开发
    import Vue from 'vue'
    
    const App = {
        template:
            `<div>
              <h2>{{message}}</h2>
            <button @click="btnClick">按钮</button>
            <h2>{{name}}</h2>
            </div>`,
        data() {
            return {
                message: 'Hello webpack',
                name: '刘云杰',
            }
        },
        methods: {
            btnClick() {
            }
        }
    }
    
    const app = new Vue({
        el: '#app',
        template: `<App/>`,
        data: {
        },
        components: {
            App
        }
    })
    ```

- 优化第二步：

  - 新建 `app.js`

    - ```js
      export default {
          template:
              `<div>
                <h2>{{message}}</h2>
              <button @click="btnClick">按钮</button>
              <h2>{{name}}</h2>
              </div>`,
          data() {
              return {
                  message: 'Hello webpack',
                  name: '刘云杰',
              }
          },
          methods: {
              btnClick() {
              }
          }
      }
      ```

  - 修改 `main.js`

    - ```js
      // 5. 使用Vue进行开发
      import Vue from 'vue'
      import App from './vue/app'
      
      const app = new Vue({
          el: '#app',
          template: `<App/>`,
          data: {
          },
          components: {
              App
          }
      })
      
      ```

- 优化第三步：

  - 新建 `App.vue`文件

    - ```vue
      <template>
        <div>
          <h2 class="title">{{ message }}</h2>
          <button @click="btnClick">按钮</button>
          <h2>{{ name }}</h2>
        </div>
      </template>
      
      <script>
      # import cpn from './cpn'
      #components: {
      #  cpn
      #}
      export default {
        name: "App",
        data() {
          return {
            message: 'Hello webpack',
            name: '刘云杰',
          }
        },
        methods: {
          btnClick() {
          }
        }
      }
      </script>
      
      <style scoped>
      .title {
        color: aquamarine;
      }
      </style>
      ```



#### 15.4.8 webpack的plugin的使用

> 什么是 `plugin`

- `plugin` 是插件的意思，通常是用于对某个现有的架构进行扩展。
- `webpack` 中的插件，就是对 `webpack` 现有功能的各种扩展，比如打包优化，文件压缩等等。

> `loader` 和 `plugin` 区别

- `loader` 主要用于转换某些类型的模块，它是一个转换器。
- `plugin` 是插件，它是对 `webpack` 本身的扩展，是一个扩展器。

> `plugin` 的使用过程：

- 步骤一：通过 `npm` 安装需要使用的 `plugins` (某些webpack已经内置的插件不需要安装)
- 步骤二：在 `webpack.config.js` 中的plugins中配置插件。



1. 添加版权的 `plugin`

   - 插件名字叫 `BannerPlugin`，属于 `webpack` 自带的插件。

   - 修改 `webpack.config.js` 文件

   - ```js
     const webpack = require('webpack')
     
     module.exports = {
         /*......*/
         /*插件*/
         plugins : [
             new webpack.BannerPlugin('版权问题'),
         ]
     }
     ```

2. `HtmlWebpackPlugin`

   - 将 `index.html` 文件打包到 `dist` 文件夹中

   - `HtmlWebpackPlugin` 插件可以为我们做这些事情：

     - 自动生成一个 `index.html` 文件(可以指定模板来生成)
     - 将打包的 `js` 文件，自动通过 `script` 标签插入到 `body` 中

   - 安装命令 `npm install html-webpack-plugin --save-dev`

   - 配置  `webpack.config.js` 文件

     - ```js
       const path = require('path')
       const webpack = require('webpack')
       const HtmlWebpackPlugin = require('html-webpack-plugin')
       
       module.exports = {
           /*插件*/
           plugins : [
               new webpack.BannerPlugin('版权问题'),
               new HtmlWebpackPlugin({
                  template: 'index.html',
               }),
           ]
       }
       ```

3. `uglifyjs-webpack-plugin`

   - 对 `js` 等文件进行压缩处理
   - `npm install uglifyjs-webpack-plugin@1.1.1 --save-dev`
   - 修改 `webpack.config.js` 文件
     - ![image-20220306132928111](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306132928111.png)

4. `webpack-dev-server`

   - 作用：搭建本地开发服务器
   - `npm install --save-dev webpack-dev-server@2.9.1`
     - `contentBase`：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist
     - `port`：端口号
     - `inline`：页面是否实时刷新
     - `historyApiFallback`：在SPA页面中，依赖HTML5的history模式
   - `webpack.config.js` 文件配置
     - ![image-20220306133425237](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306133425237.png)
     - `--open` 参数表示直接打开浏览器
     - ![image-20220306133449373](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306133449373.png)



## 16. vue-cli 脚手架

### 16.1 vue-cli介绍

**CLI是什么意思?**

- `CLI` 是 `Command-Line Interface` , 翻译为命令行界面, 但是俗称脚手架.
- `Vue CLI` 是一个官方发布 `vue.js` 项目脚手架
- 使用 `vue-cli` 可以快速搭建 `Vue` 开发环境以及对应的`webpack` 配置

**使用vue cli的前提**

- `Node.js`
- `webpack`



**安装vue脚手架**

- `npm install -g @vue/cli`
  - 上面安装的是Vue CLI3的版本，如果需要想按照Vue CLI2的方式初始化项目时不可以的。
- `cnpm install @vue/cli-init -g`
- Vue CLI2初始化项目
  - `vue init webpack my-project`
- Vue CLI3初始化项目
  - `vue create my-project`

### 16.2 vue-cli2

1. 安装过程：![image-20220306183008854](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306183008854.png)
2. 目录结构详情![image-20220306183139157](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306183139157.png)



### 16.3 Runtime-Compiler和Runtime-only的区别

- 简单总结
  - 如果在之后的开发中，你依然使用 `template`，就需要选择 `Runtime-Compiler`；
  - 如果你之后的开发中，使用的是 `.vue` 文件夹开发，那么可以选择 `Runtime-only`。
- 项目对比
  - ![image-20220306194745789](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306194745789.png)
- **Vue程序运行过程**
  - ![image-20220306195313612](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306195313612.png)

#### 16.3.1 render函数

1. ```js
   // The Vue build version to load with the `import` command
   // (runtime-only or standalone) has been set in webpack.base.conf with an alias.
   import Vue from 'vue'
   import App from './App'
   
   Vue.config.productionTip = false
   
   /* eslint-disable no-new */
   new Vue({
     el: '#app',
   
     /*render函数*/
     render: function (createElement) {
       // 1. createElement('标签', {标签的属性}, ['标签的内容'])
       return createElement('h2',
         {class: 'box'},
         ['Hello World', createElement('button', ['按钮'])]);
     }
     // components: { App },
     // template: '<App/>'
   })
   
   ```

   - ![image-20220306223833819](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306223833819.png)

2. ```js
   // The Vue build version to load with the `import` command
   // (runtime-only or standalone) has been set in webpack.base.conf with an alias.
   import Vue from 'vue'
   import App from './App'
   
   Vue.config.productionTip = false
   
   const cpn = {
     template: `<div>{{message}}</div>`,
     data() {
       return {
         message : '我是组件',
       }
     }
   }
   
   /* eslint-disable no-new */
   new Vue({
     el: '#app',
     /*render函数*/
     render: function (createElement) {
       // 2. 传入组件
       return createElement(cpn);
     }
     // components: { App },
     // template: '<App/>'
   })
   
   ```

   - ![image-20220306224226411](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306224226411.png)

   - > 进阶

   - ```js
     // The Vue build version to load with the `import` command
     // (runtime-only or standalone) has been set in webpack.base.conf with an alias.
     import Vue from 'vue'
     import App from './App'
     
     Vue.config.productionTip = false
     
     /* eslint-disable no-new */
     new Vue({
       el: '#app',
       /*render函数*/
       render: function (createElement) {
         // 2. 传入组件
         return createElement(App);
       }
       // components: { App },
       // template: '<App/>'
     })
     
     ```

   - ![image-20220306224305885](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220306224305885.png)



