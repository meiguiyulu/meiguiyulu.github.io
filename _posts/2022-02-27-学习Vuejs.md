# 学习Vue.js

## 0. ES6补充

### 0.1 `var` 没有块级作用域

> 在 `if` 和 `for` 中会出错

```html
<script>
    {
        var name = 'Hello Vue';
        console.log(name);
    }
    console.log(name);
</script>
```

![image-20220301165743759](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301165743759.png)

```html
<button>按钮1</button>
<button>按钮2</button>
<button>按钮3</button>
<button>按钮4</button>
<button>按钮5</button>
<script>
    var btns = document.getElementsByTagName("button");
    for (var i =0;i<btns.length;++i) {
        btns[i].addEventListener('click', function () {
            console.log('第' + i + '个按钮被点击')
        })
    }
</script>
```

![image-20220301182223932](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301182223932.png)

### 0.2 `const` 的使用

- 使用 `const` 修饰的标识符为常量, 不可以再次赋值.
- 当我们修饰的标识符不会被再次赋值时, 就可以使用 `const` 来保证数据的安全性.
- **建议： 在ES6开发中优先使用 `const`, 只有需要改变某一个标识符的时候才使用 `let.`** 

- ![image-20220301192236087](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301192236087.png)
- ![image-20220301192325647](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301192325647.png)
- ![image-20220301192547339](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301192547339.png)

### 0.3 `ES6` 对象字面量增强写法

1. 属性的增强写法

   ```json
       // 1. 属性的增强写法
       const name = 'why';
       const age = 18;
       const height = 1.88;
   
       // ES5的写法
       const  obj1 = {
           name: name,
           age: age,
           height: height,
       }
   
       // ES6的写法
       const onj2 = {
           name, age, height
       }
   ```

2. 方法的属性增强

   ```json
       /*2. 方法的属性增强*/
       // ES5的写法
       const ob1 = {
           run: function () {
   
           }
       }
   
       // ES6的写法
       const ob2 = {
           run() {
               
           }
       }
   ```

## 1. 介绍

Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。

- 渐进式意味着可以将 Vue 作为应用的一部分嵌入其中，带来更丰富的交互体验。

## 2. Vue.js初体验

### 2.1 第一个Vue.js程序

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<div id="app">{{message}}</div>

<body>
<script src="../js/vue.js"></script>
<script>
    // let定义变量 const定义常量
    // 编程范式：声明式编程
    /*好处：数据与界面完全分离*/
    let app = new Vue({
        el: '#app', // 定义要挂载的元素
        data: { // 定义数据
            message: 'Hello Vue.js',
        }
    })
</script>
</body>
</html>
```

![image-20220227170229059](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220227170229059.png)

### 2.2 Vue列表的展示

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<div id="app">
    <p>{{message}}</p>
    <ul>
        <li v-for="movie in movies">{{movie}}</li>
    </ul>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            message: 'Hello Vue.js',
            movies: ['星际穿越', '大话西游', '少年派', '盗梦空间'],
        }
    })
</script>

</body>
</html>
```

![image-20220227212250428](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220227212250428.png)

### 2.3 计数器

- 实现功能：小的计数器
  - 点击 `+` 计数器加1
  - 点击 `-` 计数器减1

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<div id="app">
    <h2>当前记数: {{counter}}</h2>
    <!--方法一：-->
<!--    <button v-on:click="++counter">+</button>
    <button v-on:click="&#45;&#45;counter">-</button>-->
    <!--方法二：-->
    <button v-on:click="add"></button>
    <button v-on:click="sub"></button>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            counter: 0,
        },
        methods: {
            add: function () {
                console.log("add被执行");
                this.counter++;
            },
            sub: function () {
                console.log("sub被执行");
                this.counter--;
            }
        }
    })
</script>

</body>
</html>
```

![image-20220227213529130](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220227213529130.png)

## 3. Vue中的MVVM

### 3.1 什么是MVVM

`MVVM` 是 `Model–view–viewmodel`的缩写，是一种软件[架构模式](https://zh.wikipedia.org/wiki/架构模式)。 

`MVVM` 有助于将 图形用户界面 的开发与 业务逻辑 或 后端逻辑（*数据模型*）的开发开来，这是通过 置标语言 或GUI代码实现的。`MVVM` 的*视图模型*是一个值转换器，这意味着视图模型负责从模型中暴露（转换） 数据对象 ，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现 中介者模式 ，组织对视图所支持的 用例 集的后端逻辑的访问。

- 模型
  - 模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。
- 视图
  - 就像在 `MVC` 和 `MVP` 模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）
- 视图模型
  - 视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。
- 绑定器
  - 声明性数据和命令绑定隐含在 `MVVM` 模式中。在Microsoft解决方案堆中，绑定器是一种名为 `XAML` 的标记语言。 绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。

### 3.2 Vue中的MVVM



## 4. Vue的生命周期

![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/lifecycle.png)

可以看到在 `vue` 整个生命周期中会有很多 **钩子函数 **提供给我们在 `vue` 生命周期不同的时刻进行操作：

- **beforeCreate**
- **created**
- **beforeMount**
- **mounted**
- **beforeUpdate**
- **updated**
- **beforeDestroy**
- **destroyed**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue生命周期学习</title>
  <script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"></script>
</head>
<body>
  <div id="app">
    <h1>{{message}}</h1>
  </div>
</body>
<script>
  var vm = new Vue({
    el: '#app',
    data: {
      message: 'Vue的生命周期'
    },
    beforeCreate: function() {
      console.group('------beforeCreate创建前状态------');
      console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined
      console.log("%c%s", "color:red","data   : " + this.$data); //undefined 
      console.log("%c%s", "color:red","message: " + this.message) 
    },
    created: function() {
      console.group('------created创建完毕状态------');
      console.log("%c%s", "color:red","el     : " + this.$el); //undefined
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化 
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化
    },
    beforeMount: function() {
      console.group('------beforeMount挂载前状态------');
      console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化
      console.log(this.$el);
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化  
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化  
    },
    mounted: function() {
      console.group('------mounted 挂载结束状态------');
      console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化
      console.log(this.$el);    
      console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
      console.log("%c%s", "color:red","message: " + this.message); //已被初始化 
    },
    beforeUpdate: function () {
      console.group('beforeUpdate 更新前状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el);   
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message); 
    },
    updated: function () {
      console.group('updated 更新完成状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el); 
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message); 
    },
    beforeDestroy: function () {
      console.group('beforeDestroy 销毁前状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el);    
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message); 
    },
    destroyed: function () {
      console.group('destroyed 销毁完成状态===============》');
      console.log("%c%s", "color:red","el     : " + this.$el);
      console.log(this.$el);  
      console.log("%c%s", "color:red","data   : " + this.$data); 
      console.log("%c%s", "color:red","message: " + this.message)
    }
  })
</script>
</html>
```

![image-20220228181528411](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228181528411.png)

1. ##### **在 `beforeCreate` 和 `created` 钩子函数之间的生命周期**

   - 在这个生命周期之间，进行**初始化事件，进行数据的观测**，可以看到在 **`created`** 的时候数据已经和 **`data` 属性进行绑定**（放在 `data` 中的属性当值发生改变的同时，视图也会改变）。
   - 注意看下：此时还是没有 `el` 选项

2. ##### **`created`钩子函数和 `beforeMount`间的生命周期**

   - 首先会判断对象是否有**el选项**。**如果有的话就继续向下编译，如果没有**el选项**，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。**

     - 如果注释掉代码 `el: '#app'`, 运行可以到 `created` 的时候就停止了：

     - ![img](https://segmentfault.com/img/bVVUB3/view?w=764&h=285)

     - 如果我们在后面继续调用 `vm.$mount(el)`, 可以发现代码继续向下执行了

     - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUCG)

     - 我们往下看，**`template`** 参数选项的有无对生命周期的影响。

       - 如果 `vue` 实例对象中有 `template` 参数选项，则将其作为模板编译成 `render` 函数。

       - 如果没有 `template` 选项，则将外部 `HTML` 作为模板编译。

       - 可以看到 `template` 中的模板优先级要高于 `outer HTML` 的优先级。

       - 举例：在HTML结构中增加了一串html，在vue对象中增加了**template选项**：

       - ```java
         <!DOCTYPE html>
         <html lang="en">
         <head>
           <meta charset="UTF-8">
           <meta name="viewport" content="width=device-width, initial-scale=1.0">
           <meta http-equiv="X-UA-Compatible" content="ie=edge">
           <title>vue生命周期学习</title>
           <script src="https://cdn.bootcss.com/vue/2.4.2/vue.js"></script>
         </head>
         <body>
           <div id="app">
             <!--html中修改的-->
             <h1>{{message + '这是在outer HTML中的'}}</h1>
           </div>
         </body>
         <script>
           var vm = new Vue({
             el: '#app',
             template: "<h1>{{message +'这是在template中的'}}</h1>", //在vue配置项中修改的
             data: {
               message: 'Vue的生命周期'
             }
         </script>
         </html>
         ```

       - 执行后的结果可以看到在页面中显示的是：

       - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUJT)

       - 将 `vue` 对象中 `template` 的选项注释掉后打印如下信息：

       - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUJ3)

       - 在vue对象中还有一个**render函数**，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.

       - ```java
         new Vue({
             el: '#app',
             render: function(createElement) {
                 return createElement('h1', 'this is createElement')
             }
         })
         ```

       - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUSo)

     - 所以综合排名优先级：`render` 函数选项 > `template` 选项 > o`uter HTML`.

3. ##### **`beforeMount` 和 `mounted`  钩子函数间的生命周期**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUTK)
   - 给 `vue` 实例对象添加 **`el成员`**，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到 **`beforeMount` **之前 `el` 上还是 `undefined`。

4. ##### **`mounted`**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVUYC)
   - 在 `mounted` 之前 `h1` 中还是通过  **`{{message}}`**进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在 `mounted` 之后可以看到 `h1` 中的内容发生了变化

5. ##### **`beforeUpdate` 钩子函数和 `updated` 钩子函数间的生命周期**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVU0E)
   - 当vue发现data中的数据发生了改变，会**触发对应组件的重新渲染**，先后调用**beforeUpdate**和**updated**钩子函数。我们在console中输入 `vm.message = '触发组件更新'`
   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVU55)

6. ##### **`beforeDestroy` 和 `destroyed` 钩子函数间的生命周期**

   - ![img](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/bVVU6C)
   - **`beforeDestroy`**钩子函数在实例销毁之前调用。在这一步，实例仍然完全可用。
   - **`destroyed`**钩子函数在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁



## 5. Vue基础语法

### 5.1 Mustache语法

`Mustache` 语法即 `Vue` 中的 `{{ }}` 语法。

![image-20220228162835910](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228162835910.png)

### 5.2 v-once指令

> - 该指令后不需要跟任何表达式
> - 该指令表示元素和组件只渲染一次，不会随着数据的改变而改变。

```html
<div id="app">
    <h2>{{ message }}</h2>
    <h2 v-once>{{ message }}</h2>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            counter: 0,
            message: ' Hello Vue,js',
            firstName: 'kobe',
            lastName: 'bryant',
        },
        methods: {
            add: function () {
                console.log("add被执行");
                this.counter++;
            },
            sub: function () {
                console.log("sub被执行");
                this.counter--;
            }
        }
    })
</script>
```

![image-20220228163236610](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228163236610.png)

### 5.3 v-html指令

> 解析带有 `html` 标签的字符串 `v-html=""`

![image-20220228184820786](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228184820786.png)

### 5.4 v-text指令

`v-text` 指令的作用与 `Mustache` 相似，都是用于将数据显示在界面中。

接收的数据类型为 `string`。

![image-20220228185237906](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228185237906.png)

### 5.5 v-pr指令

> 不解析 `{{}}` 内部的语句

![image-20220228192629843](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228192629843.png)

### 5.6 v-cloak指令

> - 在 `vue` 解析之前，`div` 中存在属性 `v-clock`
> - 在 `vue` 解析之后，`div` 中没有属性 `v-clock`

### 5.7 v-bind指令

> 作用：动态绑定属性
>
> - 例如动态绑定 `a` 元素的 `href` 属性；
> - 例如动态绑定 `img` 元素的 `src` 属性；
>
> 可以使用 `:` 代替 `v-bind`。

#### 5.7.1 v-bind简单使用

![image-20220228195241621](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228195241621.png)

#### 5.7.2 v-bind动态绑定class

- 对象语法

  - ![image-20220228202527463](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228202527463.png)
  - ![image-20220228203514707](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228203514707.png)

- 数组语法

  - ```html
    <div id="app">
        <h2 class="title" :class="['active', 'line']">{{message}}</h2>
    </div>
    ```

  - ![image-20220228203813692](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220228203813692.png)

#### 5.8.3 v-bind动态绑定style

> 对象语法

```html
<div id="app">
<!--    <h2 :style="{属性名:属性值}">{{message}}</h2>-->

    <!--'0px'必须加上单引号 否则是当作变量去解析
    驼峰标识的时候 fontSize 不需要加单引号
    -标识的时候 'font-size'也需要加单引号
    -->
    <h2 :style="{fontSize: '50px'}">{{message}}</h2>
    <h2 :style="{'font-size': '50px'}">{{message}}</h2>
    <h2 :style="{fontSize: size}">{{message}}</h2>
</div>
<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            message: '你好呀',
            size: '100px'
        },
    })
```

![image-20220301150004990](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301150004990.png)

> 数组语法

![image-20220301150353552](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301150353552.png)

## 6. 计算属性

### 6.1 计算属性的简单操作

> `computed` 类似于 `methods`

```html
<div id="app">
    <h2>{{firstName + ' ' + lastName}}</h2>
    <h2>{{firstName}} {{lastName}}</h2>
    <h2>{{getFullName()}}</h2>
    <!--计算属性-->
    <h2>{{fullName}}</h2>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            firstName: '刘',
            lastName: '撷思',
        },
        /*计算属性*/
        computed: {
            fullName: function () {
                return this.firstName + ' ' + this.lastName;

            }
        },
        methods: {
            getFullName: function () {
                return this.firstName + ' ' + this.lastName;
            }
        }
    })
</script>
```

![image-20220301152057665](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301152057665.png)

### 6.2 计算属性的复杂操作

```html
<div id="app">
    <h2>总价格: {{totalPrice1}}</h2>
    <h2>总价格: {{totalPrice2}}</h2>
</div>

<script src="../js/vue.js"></script>
<script>
    let app = new Vue({
        el: "#app",
        data: {
            books: [
                {id: 110, name: '深入理解计算机原理', price: 100},
                {id: 111, name: '现代操作系统', price: 105},
                {id: 112, name: '深入理解Java虚拟机', price: 110},
            ]
        },
        /*计算属性*/
        computed: {
            totalPrice1: function () {
                let ans = 0;
                for (let i=0;i<this.books.length;i++) {
                    ans += this.books[i].price;
                }
                return ans;
            },
            totalPrice2: function () {
                let ans = 0;
                for (let book of this.books) {
                    ans += book.price;
                }
                return ans;
            },
        },
    })
</script>
```

![image-20220301154513741](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301154513741.png)

### 6.3 计算属性的 setter 和 getter



![image-20220301162227779](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301162227779.png)



### 6.4 计算属性和methods的区别

> - 计算属性会判断数据的值是否发生变化，如果没有发生变化，则不会重新执行，使用缓存的数据；
> - `methods` 调用几次执行几次，不会去判断数据的值是否发生了改变。

- 使用 `methods`

  - ```html
    <div id="app">
        <!--方法二：调用methods-->
        <h2>{{getFullName()}}</h2>
        <h2>{{getFullName()}}</h2>
        <h2>{{getFullName()}}</h2>
        <h2>{{getFullName()}}</h2>
    </div>
    
    <script src="../js/vue.js"></script>
    <script>
        let app = new Vue({
            el: "#app",
            data: {
                firstName: '刘',
                lastName: '撷思',
            },
            methods: {
                getFullName: function () {
                    console.log('getFullName');
                    return this.firstName + ' ' + this.lastName;
                }
            }
        })
    </script>
    ```

  - ![image-20220301163131677](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301163131677.png)

  - > `methods` 调用了 4 次

- 使用计算属性

  - ```html
    <div id="app">
    <!--    方法三：计算属性-->
        <h2>{{fullName}}</h2>
        <h2>{{fullName}}</h2>
        <h2>{{fullName}}</h2>
        <h2>{{fullName}}</h2>
    </div>
    
    <script src="../js/vue.js"></script>
    <script>
        let app = new Vue({
            el: "#app",
            data: {
                firstName: '刘',
                lastName: '撷思',
            },
            /*计算属性*/
            computed: {
                fullName: function () {
                    console.log('fullName');
                    return this.firstName + ' ' + this.lastName;
                }
            },
        })
    </script>
    ```

  - ![image-20220301163324978](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301163324978.png)

  - > 只有一次

## 7. v-on

### 7.1 v-on的基本使用和语法糖

> 在前端开发中，需要经常和用户交互。在这个时候，就需要监听用户发出的指令，如点击、拖拽、键盘时间等。
>
> 在 `Vue` 中监听事件使用 `v-on` 指令。

**`v-on` 介绍：**

- **作用：**绑定事件监听器
- **缩写：** `@`

![image-20220301200322508](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301200322508.png)

### 7.2 v-on的参数传递

```html
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            counter: 0,
        },
        methods: {
            btn1Click() {
                console.log("btn1Click");
            }
        }
    })
</script>
```

- 如果该方法不需要额外参数，那么方法后的 `()` 可以不添加。

  - ```html
        <!--事件调用的方法没有参数-->
        <button @click="btn1Click()">按钮1</button>
        <button @click="btn1Click">按钮1-1</button>
    ```

  - ![image-20220301200839221](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301200839221.png)

- 如果方法本身中有一个参数，那么会默认将原生事件 `event` 参数传递进去

  - ```html
        <!--事件调用的方法需要参数-->
        <button @click="btn2Click(123)">按钮2</button>
        <button @click="btn2Click">按钮2-2</button>
    ```

  - ![image-20220301201303543](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301201303543.png)

- 如果需要同时传入某个参数，同时需要 `event` 时，可以通过 `$event` 传入事件

  - ```html
        <!--事件调用的方法需要event对象，也需要其他参数-->
        <button @click="btn3Click">按钮3</button>
        <button @click="btn3Click()">按钮3-1</button>
        <button @click="btn3Click(123)">按钮3-2</button>
        <button @click="btn3Click(123, $event)">按钮3-4</button>
    ```

  - ![image-20220301202133531](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301202133531.png)

### 7.3 v-on修饰符

- 在某些情况下，我们拿到 `event` 的目的可能是进行一些事件处理。
- `Vue` 提供了修饰符来帮助我们方便的处理一些事件：
  - `.stop` - 调用 `event.stopPropagation()`。
  - `.prevent` - 调用 `event.preventDefault()`。
  - `.{keyCode | keyAlias}` - 只当事件是从特定键触发时才触发回调。
  - `.native` - 监听组件根元素的原生事件。
  - `.once` - 只触发一次回调。

![image-20220301202955018](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301202955018.png)

## 8. v-if 条件判断

### 8.1 v-if和v-else-if和v-else的使用

![image-20220301210056659](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301210056659.png)

### 8.2 登录切换的小案例

> 切换账户登录跟邮箱登录

```html
<div id="app">
    <span v-if="type=='username'">
        <label>用户账号：</label>
        <input placeholder="用户账号">
    </span>
    <span v-else>
        <label>邮箱地址：</label>
        <input placeholder="邮箱地址">
    </span>
    <button @click="handle">切换类型</button>
</div>
<script src="../js/vue.js"></script>
<script>
    const vue = new Vue({
        el: '#app',
        data: {
            message: "你好呀",
            score: 98,
            type: 'username',
        },
        methods: {
            handle() {
                this.type = this.type == 'username' ? 'email' : 'username';
            }
        }
    })
</script>
```

![image-20220301212254794](https://gitee.com/yun-xiaojie/blog-image/raw/master/img/image-20220301212254794.png)

**问题描述：**

- 如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。
- 但是按道理讲，我们应该切换到另外一个 `input` 元素中了。
- 在另一个 `input` 元素中，我们并没有输入内容。
- 为什么会出现这个问题呢？

**问题解答：**

- 这是因为 `Vue` 在进行 `DOM` 渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。
- 在上面的案例中，`Vue` 内部会发现原来的 `input` 元素不再使用，直接作为 `else` 中的 `input` 来使用了。

**解决方案**：

- 如果我们不希望 `Vue` 出现类似重复利用的问题，可以给对应的 `input` 添加 `key`
- 并且我们需要保证 `key` 的不同

```html
<div id="app">
    <span v-if="type=='username'">
        <label>用户账号：</label>
        <input placeholder="用户账号" key="username-key">
    </span>
    <span v-else>
        <label>邮箱地址：</label>
        <input placeholder="邮箱地址" key="email-key">
    </span>
    <button @click="handle">切换类型</button>
</div>
```



### 8.3 v-show